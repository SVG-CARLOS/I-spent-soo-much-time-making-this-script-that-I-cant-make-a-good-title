-- StarterPlayerScripts > LocalScript: "SVGBobsUnhingedMorphMenu"
--!nocheck

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Player = Players.LocalPlayer
local Mouse = Player:GetMouse()

--------------------------------------------------------------------
-- REMOTE SETUP (create remotes if they don't exist, server handles damage)
--------------------------------------------------------------------
local function getOrCreateRemote(name, class)
	local r = ReplicatedStorage:FindFirstChild(name)
	if not r then
		r = Instance.new(class)
		r.Name = name
		r.Parent = ReplicatedStorage
	end
	return r
end

local DamageRemote = getOrCreateRemote("SVGBob_Damage", "RemoteEvent")
local MorphRemote = getOrCreateRemote("SVGBob_Morph", "RemoteEvent")
local FlingRemote = getOrCreateRemote("SVGBob_Fling", "RemoteEvent")
local SpinAttackRemote = getOrCreateRemote("SVGBob_SpinAttack", "RemoteEvent")

--------------------------------------------------------------------
-- SERVER SCRIPT INJECTOR (Creates a server script in ServerScriptService)
--------------------------------------------------------------------
local function setupServerHandling()
	local serverScript = ReplicatedStorage:FindFirstChild("SVGBob_ServerHandler")
	if not serverScript then
		serverScript = Instance.new("ModuleScript")
		serverScript.Name = "SVGBob_ServerHandler"
		serverScript.Source = ""
		serverScript.Parent = ReplicatedStorage
	end
	
	-- We'll handle effects locally and use remotes for damage
	DamageRemote.OnClientEvent:Connect(function() end) -- placeholder
end

--------------------------------------------------------------------
-- CREATURE DATABASE - 5 UNIQUE CREATURES WITH 4 ABILITIES EACH
--------------------------------------------------------------------

local Creatures = {
	--------------------------------------------------------------------
	-- 1. VOIDCRAWLER - Eldritch abomination from between dimensions
	--------------------------------------------------------------------
	{
		Name = "VOIDCRAWLER",
		Description = "An eldritch horror from the space between realities. Its limbs bend in directions that shouldn't exist.",
		Icon = "üëÅÔ∏è",
		Color = Color3.fromRGB(75, 0, 130),
		SecondaryColor = Color3.fromRGB(148, 0, 211),
		AccentColor = Color3.fromRGB(255, 0, 255),
		BodyScale = {Height = 1.4, Width = 0.8, Depth = 0.8, Head = 1.6},
		WalkSpeed = 22,
		JumpPower = 60,
		BodyColors = {
			HeadColor = BrickColor.new("Really black"),
			TorsoColor = BrickColor.new("Royal purple"),
			LeftArmColor = BrickColor.new("Black"),
			RightArmColor = BrickColor.new("Black"),
			LeftLegColor = BrickColor.new("Really black"),
			RightLegColor = BrickColor.new("Really black"),
		},
		Abilities = {
			{
				Name = "VOID DRILL",
				Key = "Q",
				Cooldown = 3,
				Description = "Your hand plunges INTO the enemy and spins at incomprehensible speeds, shredding them from the inside out.",
				Type = "SpinAttack",
				Damage = 45,
				Range = 12,
				SpinSpeed = 80,
				Duration = 1.5,
			},
			{
				Name = "DIMENSION RIP",
				Key = "E",
				Cooldown = 8,
				Description = "Tear a hole in reality, teleporting behind the nearest enemy and unleashing a devastating backhand.",
				Type = "Teleport",
				Damage = 35,
				Range = 50,
			},
			{
				Name = "TENTACLE ERUPTION",
				Key = "R",
				Cooldown = 12,
				Description = "Dark tentacles erupt from the ground around you, flinging everyone nearby into the stratosphere.",
				Type = "AOE",
				Damage = 30,
				Range = 25,
				FlingForce = 500,
			},
			{
				Name = "ELDRITCH GAZE",
				Key = "T",
				Cooldown = 15,
				Description = "Your massive eye opens fully, freezing all nearby players in existential dread while draining their life.",
				Type = "Stun",
				Damage = 10,
				Range = 35,
				Duration = 3,
				DPS = 15,
			},
		},
	},
	--------------------------------------------------------------------
	-- 2. INFERNO TITAN - Living volcanic colossus
	--------------------------------------------------------------------
	{
		Name = "INFERNO TITAN",
		Description = "A walking volcano given terrible consciousness. The ground melts beneath its steps.",
		Icon = "üî•",
		Color = Color3.fromRGB(255, 69, 0),
		SecondaryColor = Color3.fromRGB(255, 140, 0),
		AccentColor = Color3.fromRGB(255, 255, 0),
		BodyScale = {Height = 2.0, Width = 1.8, Depth = 1.5, Head = 0.9},
		WalkSpeed = 14,
		JumpPower = 80,
		BodyColors = {
			HeadColor = BrickColor.new("Bright red"),
			TorsoColor = BrickColor.new("Neon orange"),
			LeftArmColor = BrickColor.new("Bright red"),
			RightArmColor = BrickColor.new("Bright red"),
			LeftLegColor = BrickColor.new("Really red"),
			RightLegColor = BrickColor.new("Really red"),
		},
		Abilities = {
			{
				Name = "MAGMA FIST",
				Key = "Q",
				Cooldown = 4,
				Description = "Your superheated fist drills into the enemy, spinning like a molten turbine and launching them into orbit.",
				Type = "SpinAttack",
				Damage = 60,
				Range = 14,
				SpinSpeed = 60,
				Duration = 1.2,
			},
			{
				Name = "ERUPTION",
				Key = "E",
				Cooldown = 10,
				Description = "Slam the ground so hard it erupts, sending pillars of fire and debris skyward, flinging everyone.",
				Type = "GroundSlam",
				Damage = 50,
				Range = 30,
				FlingForce = 700,
			},
			{
				Name = "METEOR RAIN",
				Key = "R",
				Cooldown = 18,
				Description = "Call down a barrage of flaming meteors that obliterate everything in a targeted area.",
				Type = "Projectile",
				Damage = 40,
				Range = 80,
				Count = 8,
			},
			{
				Name = "HEAT AURA",
				Key = "T",
				Cooldown = 20,
				Description = "Your body temperature becomes a star. Everything near you catches fire and takes continuous damage.",
				Type = "Aura",
				Damage = 8,
				Range = 20,
				Duration = 6,
				DPS = 8,
			},
		},
	},
	--------------------------------------------------------------------
	-- 3. GLITCH PHANTOM - A corrupted digital entity
	--------------------------------------------------------------------
	{
		Name = "GLITCH PHANTOM",
		Description = "A corrupted entity made of broken code and shattered pixels. Reality itself glitches around it.",
		Icon = "‚ö°",
		Color = Color3.fromRGB(0, 255, 128),
		SecondaryColor = Color3.fromRGB(0, 200, 255),
		AccentColor = Color3.fromRGB(255, 0, 100),
		BodyScale = {Height = 1.1, Width = 0.7, Depth = 0.7, Head = 1.3},
		WalkSpeed = 32,
		JumpPower = 70,
		BodyColors = {
			HeadColor = BrickColor.new("Lime green"),
			TorsoColor = BrickColor.new("Dark stone grey"),
			LeftArmColor = BrickColor.new("Lime green"),
			RightArmColor = BrickColor.new("Cyan"),
			LeftLegColor = BrickColor.new("Dark stone grey"),
			RightLegColor = BrickColor.new("Dark stone grey"),
		},
		Abilities = {
			{
				Name = "CORRUPTED BORE",
				Key = "Q",
				Cooldown = 2.5,
				Description = "Your glitched hand phases into the enemy and spins like a broken motor, causing catastrophic system errors (death).",
				Type = "SpinAttack",
				Damage = 35,
				Range = 10,
				SpinSpeed = 120,
				Duration = 0.8,
			},
			{
				Name = "GLITCH DASH",
				Key = "E",
				Cooldown = 3,
				Description = "Teleport rapidly in your look direction, leaving behind corrupted afterimages that damage anyone who touches them.",
				Type = "Dash",
				Damage = 20,
				Range = 60,
				Afterimages = 5,
			},
			{
				Name = "PIXEL STORM",
				Key = "R",
				Cooldown = 10,
				Description = "Shatter yourself into a thousand glitched pixels that swarm enemies, each one dealing damage.",
				Type = "Swarm",
				Damage = 3,
				Range = 30,
				Count = 50,
			},
			{
				Name = "BLUE SCREEN",
				Key = "T",
				Cooldown = 25,
				Description = "Force all nearby players to experience a BSOD. Their screen fills with error text while they take massive damage.",
				Type = "ScreenEffect",
				Damage = 70,
				Range = 40,
				Duration = 3,
			},
		},
	},
	--------------------------------------------------------------------
	-- 4. BONE LEVIATHAN - Skeletal sea-monster that walks on land
	--------------------------------------------------------------------
	{
		Name = "BONE LEVIATHAN",
		Description = "An ancient skeletal sea beast that dragged itself onto land. Its bones rattle with the fury of drowned sailors.",
		Icon = "üíÄ",
		Color = Color3.fromRGB(200, 200, 180),
		SecondaryColor = Color3.fromRGB(100, 150, 150),
		AccentColor = Color3.fromRGB(0, 255, 200),
		BodyScale = {Height = 1.7, Width = 1.5, Depth = 1.3, Head = 1.8},
		WalkSpeed = 18,
		JumpPower = 50,
		BodyColors = {
			HeadColor = BrickColor.new("Institutional white"),
			TorsoColor = BrickColor.new("Light stone grey"),
			LeftArmColor = BrickColor.new("Institutional white"),
			RightArmColor = BrickColor.new("Institutional white"),
			LeftLegColor = BrickColor.new("Light stone grey"),
			RightLegColor = BrickColor.new("Light stone grey"),
		},
		Abilities = {
			{
				Name = "BONE AUGER",
				Key = "Q",
				Cooldown = 3.5,
				Description = "Your skeletal hand impales and corkscrews through the enemy at nauseating speed. Bones splinter. They die.",
				Type = "SpinAttack",
				Damage = 50,
				Range = 13,
				SpinSpeed = 90,
				Duration = 1.3,
			},
			{
				Name = "RIBCAGE PRISON",
				Key = "E",
				Cooldown = 12,
				Description = "Giant ribs erupt from the ground, trapping nearby enemies in a cage of bone while crushing inward.",
				Type = "Trap",
				Damage = 40,
				Range = 20,
				Duration = 4,
			},
			{
				Name = "MARROW CANNON",
				Key = "R",
				Cooldown = 7,
				Description = "Fire a concentrated beam of liquefied bone marrow that pierces through multiple enemies.",
				Type = "Beam",
				Damage = 55,
				Range = 100,
				Width = 5,
			},
			{
				Name = "MASS GRAVE",
				Key = "T",
				Cooldown = 22,
				Description = "The ground becomes a mass grave. Skeletal hands reach up, grabbing all nearby enemies and pulling them underground.",
				Type = "AOE",
				Damage = 60,
				Range = 35,
				FlingForce = -300,
				Duration = 3,
			},
		},
	},
	--------------------------------------------------------------------
	-- 5. STATIC KING - Entity made of pure TV static and noise
	--------------------------------------------------------------------
	{
		Name = "STATIC KING",
		Description = "Born from a thousand dead television channels. Its body is pure noise, and its voice is the sound between stations.",
		Icon = "üì∫",
		Color = Color3.fromRGB(180, 180, 180),
		SecondaryColor = Color3.fromRGB(50, 50, 50),
		AccentColor = Color3.fromRGB(255, 255, 255),
		BodyScale = {Height = 1.3, Width = 1.2, Depth = 1.0, Head = 2.0},
		WalkSpeed = 20,
		JumpPower = 55,
		BodyColors = {
			HeadColor = BrickColor.new("Medium stone grey"),
			TorsoColor = BrickColor.new("Dark stone grey"),
			LeftArmColor = BrickColor.new("Medium stone grey"),
			RightArmColor = BrickColor.new("Medium stone grey"),
			LeftLegColor = BrickColor.new("Dark stone grey"),
			RightLegColor = BrickColor.new("Dark stone grey"),
		},
		Abilities = {
			{
				Name = "SIGNAL SCRAMBLE",
				Key = "Q",
				Cooldown = 3,
				Description = "Your static-charged hand phases into the enemy and vibrates at every frequency simultaneously. They disintegrate.",
				Type = "SpinAttack",
				Damage = 42,
				Range = 11,
				SpinSpeed = 100,
				Duration = 1.0,
			},
			{
				Name = "CHANNEL SURF",
				Key = "E",
				Cooldown = 5,
				Description = "Rapidly switch between 'channels' (positions), appearing and disappearing unpredictably while striking.",
				Type = "MultiTeleport",
				Damage = 15,
				Range = 30,
				Strikes = 6,
			},
			{
				Name = "DEAD AIR",
				Key = "R",
				Cooldown = 14,
				Description = "Create a zone of absolute silence and visual static. Enemies inside are blinded, deafened, and taking damage.",
				Type = "Zone",
				Damage = 5,
				Range = 25,
				Duration = 5,
				DPS = 12,
			},
			{
				Name = "EMERGENCY BROADCAST",
				Key = "T",
				Cooldown = 30,
				Description = "THE ULTIMATE. An ear-splitting emergency broadcast tone that deals catastrophic damage and flings everyone away.",
				Type = "Ultimate",
				Damage = 90,
				Range = 50,
				FlingForce = 1000,
			},
		},
	},
}

--------------------------------------------------------------------
-- STATE MANAGEMENT
--------------------------------------------------------------------
local CurrentMorph = nil -- index into Creatures
local Cooldowns = {} -- [abilityKey] = tick when ready
local IsMenuOpen = false
local MorphParts = {} -- extra parts added during morph
local ActiveEffects = {} -- running effects
local IsAttacking = false

--------------------------------------------------------------------
-- UTILITY FUNCTIONS
--------------------------------------------------------------------
local function GetCharacter()
	return Player.Character or Player.CharacterAdded:Wait()
end

local function GetHumanoid()
	local char = GetCharacter()
	return char and char:FindFirstChildOfClass("Humanoid")
end

local function GetHRP()
	local char = GetCharacter()
	return char and char:FindFirstChild("HumanoidRootPart")
end

local function GetNearbyPlayers(range)
	local hrp = GetHRP()
	if not hrp then return {} end
	local nearby = {}
	for _, p in ipairs(Players:GetPlayers()) do
		if p ~= Player and p.Character then
			local otherHRP = p.Character:FindFirstChild("HumanoidRootPart")
			if otherHRP then
				local dist = (hrp.Position - otherHRP.Position).Magnitude
				if dist <= range then
					table.insert(nearby, {Player = p, Character = p.Character, HRP = otherHRP, Distance = dist})
				end
			end
		end
	end
	table.sort(nearby, function(a, b) return a.Distance < b.Distance end)
	return nearby
end

local function GetClosestPlayer(range)
	local nearby = GetNearbyPlayers(range)
	return nearby[1]
end

local function DealDamage(targetChar, amount)
	local humanoid = targetChar:FindFirstChildOfClass("Humanoid")
	if humanoid then
		humanoid:TakeDamage(amount)
	end
end

local function FlingTarget(targetHRP, force, direction)
	if targetHRP then
		local bv = Instance.new("BodyVelocity")
		bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
		bv.Velocity = direction * force
		bv.Parent = targetHRP
		Debris:AddItem(bv, 0.3)
		
		local bg = Instance.new("BodyAngularVelocity")
		bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
		bg.AngularVelocity = Vector3.new(
			math.random(-50, 50),
			math.random(-50, 50),
			math.random(-50, 50)
		)
		bg.Parent = targetHRP
		Debris:AddItem(bg, 0.5)
	end
end

--------------------------------------------------------------------
-- PARTICLE & VISUAL EFFECTS
--------------------------------------------------------------------
local function CreateParticleEffect(parent, color, rate, speed, lifetime, size, shape, transparency)
	local pe = Instance.new("ParticleEmitter")
	pe.Color = ColorSequence.new(color)
	pe.Rate = rate or 50
	pe.Speed = NumberRange.new(speed or 5)
	pe.Lifetime = NumberRange.new(lifetime or 1)
	pe.Size = NumberSequence.new(size or 1)
	pe.Shape = shape or Enum.ParticleEmitterShape.Sphere
	pe.Transparency = NumberSequence.new(transparency or 0.3)
	pe.LightEmission = 0.8
	pe.LightInfluence = 0.2
	pe.SpreadAngle = Vector2.new(180, 180)
	pe.Parent = parent
	return pe
end

local function CreateExplosionEffect(position, color, size, duration)
	local part = Instance.new("Part")
	part.Shape = Enum.PartType.Ball
	part.Size = Vector3.new(1, 1, 1)
	part.Position = position
	part.Anchored = true
	part.CanCollide = false
	part.Material = Enum.Material.Neon
	part.Color = color
	part.Transparency = 0.3
	part.Parent = workspace
	
	local light = Instance.new("PointLight")
	light.Color = color
	light.Brightness = 5
	light.Range = size * 2
	light.Parent = part
	
	TweenService:Create(part, TweenInfo.new(duration or 0.5, Enum.EasingStyle.Expo, Enum.EasingDirection.Out), {
		Size = Vector3.new(size, size, size),
		Transparency = 1,
	}):Play()
	
	TweenService:Create(light, TweenInfo.new(duration or 0.5), {
		Brightness = 0,
	}):Play()
	
	Debris:AddItem(part, duration or 0.5)
	return part
end

local function CreateBeamEffect(startPos, endPos, color, width, duration)
	local distance = (endPos - startPos).Magnitude
	local midPoint = (startPos + endPos) / 2
	
	local beam = Instance.new("Part")
	beam.Size = Vector3.new(width or 2, width or 2, distance)
	beam.CFrame = CFrame.lookAt(midPoint, endPos)
	beam.Anchored = true
	beam.CanCollide = false
	beam.Material = Enum.Material.Neon
	beam.Color = color
	beam.Transparency = 0.2
	beam.Parent = workspace
	
	local light = Instance.new("PointLight")
	light.Color = color
	light.Brightness = 3
	light.Range = 15
	light.Parent = beam
	
	TweenService:Create(beam, TweenInfo.new(duration or 0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Transparency = 1,
		Size = Vector3.new((width or 2) * 3, (width or 2) * 3, distance),
	}):Play()
	
	Debris:AddItem(beam, duration or 0.3)
	return beam
end

local function CreateRingEffect(position, color, maxSize, duration)
	local ring = Instance.new("Part")
	ring.Shape = Enum.PartType.Cylinder
	ring.Size = Vector3.new(0.3, 1, 1)
	ring.CFrame = CFrame.new(position) * CFrame.Angles(0, 0, math.rad(90))
	ring.Anchored = true
	ring.CanCollide = false
	ring.Material = Enum.Material.Neon
	ring.Color = color
	ring.Transparency = 0.3
	ring.Parent = workspace
	
	TweenService:Create(ring, TweenInfo.new(duration or 0.8, Enum.EasingStyle.Expo, Enum.EasingDirection.Out), {
		Size = Vector3.new(0.3, maxSize, maxSize),
		Transparency = 1,
	}):Play()
	
	Debris:AddItem(ring, duration or 0.8)
	return ring
end

local function ShakeCamera(intensity, duration)
	local cam = workspace.CurrentCamera
	local startTime = tick()
	local conn
	conn = RunService.RenderStepped:Connect(function()
		local elapsed = tick() - startTime
		if elapsed >= duration then
			conn:Disconnect()
			return
		end
		local remaining = 1 - (elapsed / duration)
		local offset = Vector3.new(
			math.random() * 2 - 1,
			math.random() * 2 - 1,
			math.random() * 2 - 1
		) * intensity * remaining
		cam.CFrame = cam.CFrame * CFrame.new(offset)
	end)
end

local function FlashScreen(color, duration)
	local gui = Player:FindFirstChild("PlayerGui")
	if not gui then return end
	
	local screen = Instance.new("ScreenGui")
	screen.Name = "SVGFlash"
	screen.IgnoreGuiInset = true
	screen.Parent = gui
	
	local frame = Instance.new("Frame")
	frame.Size = UDim2.new(1, 0, 1, 0)
	frame.BackgroundColor3 = color
	frame.BackgroundTransparency = 0.3
	frame.BorderSizePixel = 0
	frame.Parent = screen
	
	TweenService:Create(frame, TweenInfo.new(duration or 0.3), {
		BackgroundTransparency = 1
	}):Play()
	
	Debris:AddItem(screen, duration or 0.3)
end

--------------------------------------------------------------------
-- MORPH SYSTEM
--------------------------------------------------------------------
local function ClearMorph()
	-- Remove extra parts
	for _, part in ipairs(MorphParts) do
		if part and part.Parent then
			part:Destroy()
		end
	end
	MorphParts = {}
	
	-- Stop active effects
	for _, effect in ipairs(ActiveEffects) do
		if typeof(effect) == "Instance" then
			effect:Destroy()
		elseif typeof(effect) == "RBXScriptConnection" then
			effect:Disconnect()
		end
	end
	ActiveEffects = {}
	
	-- Reset character
	local char = GetCharacter()
	local humanoid = GetHumanoid()
	if humanoid then
		humanoid.WalkSpeed = 16
		humanoid.JumpPower = 50
	end
	
	-- Reset body colors
	local bc = char:FindFirstChildOfClass("BodyColors")
	if bc then bc:Destroy() end
	
	-- Remove scaling
	if humanoid then
		for _, v in ipairs(humanoid:GetChildren()) do
			if v:IsA("NumberValue") and (v.Name == "BodyHeightScale" or v.Name == "BodyWidthScale" or v.Name == "BodyDepthScale" or v.Name == "HeadScale") then
				v:Destroy()
			end
		end
	end
	
	-- Remove particle effects from body
	for _, part in ipairs(char:GetDescendants()) do
		if part:IsA("ParticleEmitter") and part.Name == "SVGMorphEffect" then
			part:Destroy()
		end
		if part:IsA("PointLight") and part.Name == "SVGMorphLight" then
			part:Destroy()
		end
	end
	
	CurrentMorph = nil
	Cooldowns = {}
end

local function ApplyBodyScale(humanoid, scales)
	local function setScale(name, value)
		local existing = humanoid:FindFirstChild(name)
		if not existing then
			existing = Instance.new("NumberValue")
			existing.Name = name
			existing.Parent = humanoid
		end
		existing.Value = value
	end
	
	setScale("BodyHeightScale", scales.Height or 1)
	setScale("BodyWidthScale", scales.Width or 1)
	setScale("BodyDepthScale", scales.Depth or 1)
	setScale("HeadScale", scales.Head or 1)
end

local function ApplyBodyColors(char, colors)
	local bc = char:FindFirstChildOfClass("BodyColors")
	if not bc then
		bc = Instance.new("BodyColors")
		bc.Parent = char
	end
	
	bc.HeadColor = colors.HeadColor or BrickColor.new("Medium stone grey")
	bc.TorsoColor = colors.TorsoColor or BrickColor.new("Medium stone grey")
	bc.LeftArmColor = colors.LeftArmColor or BrickColor.new("Medium stone grey")
	bc.RightArmColor = colors.RightArmColor or BrickColor.new("Medium stone grey")
	bc.LeftLegColor = colors.LeftLegColor or BrickColor.new("Medium stone grey")
	bc.RightLegColor = colors.RightLegColor or BrickColor.new("Medium stone grey")
end

local function AddMorphDecorations(char, creature)
	local hrp = char:FindFirstChild("HumanoidRootPart")
	local head = char:FindFirstChild("Head")
	local torso = char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso")
	local rightArm = char:FindFirstChild("Right Arm") or char:FindFirstChild("RightUpperArm")
	local leftArm = char:FindFirstChild("Left Arm") or char:FindFirstChild("LeftUpperArm")
	
	-- Aura particles on torso
	if torso then
		local pe = CreateParticleEffect(torso, creature.Color, 20, 2, 1.5, 0.5, Enum.ParticleEmitterShape.Sphere, 0.5)
		pe.Name = "SVGMorphEffect"
		table.insert(ActiveEffects, pe)
		
		local light = Instance.new("PointLight")
		light.Name = "SVGMorphLight"
		light.Color = creature.Color
		light.Brightness = 1.5
		light.Range = 12
		light.Parent = torso
		table.insert(ActiveEffects, light)
	end
	
	-- Eye glow on head
	if head then
		local pe = CreateParticleEffect(head, creature.AccentColor, 10, 1, 0.8, 0.3, Enum.ParticleEmitterShape.Sphere, 0.4)
		pe.Name = "SVGMorphEffect"
		table.insert(ActiveEffects, pe)
	end
	
	-- Creature-specific decorations
	if creature.Name == "VOIDCRAWLER" then
		-- Add floating eye above head
		if head then
			local eye = Instance.new("Part")
			eye.Shape = Enum.PartType.Ball
			eye.Size = Vector3.new(1.5, 1.5, 1.5)
			eye.Material = Enum.Material.Neon
			eye.Color = creature.AccentColor
			eye.CanCollide = false
			eye.Massless = true
			eye.Parent = char
			
			local weld = Instance.new("Weld")
			weld.Part0 = head
			weld.Part1 = eye
			weld.C0 = CFrame.new(0, 2, 0)
			weld.Parent = eye
			
			table.insert(MorphParts, eye)
			
			-- Pupil
			local pupil = Instance.new("Part")
			pupil.Shape = Enum.PartType.Ball
			pupil.Size = Vector3.new(0.6, 0.6, 0.6)
			pupil.Material = Enum.Material.Neon
			pupil.Color = Color3.new(0, 0, 0)
			pupil.CanCollide = false
			pupil.Massless = true
			pupil.Parent = char
			
			local pw = Instance.new("Weld")
			pw.Part0 = eye
			pw.Part1 = pupil
			pw.C0 = CFrame.new(0, 0, -0.5)
			pw.Parent = pupil
			
			table.insert(MorphParts, pupil)
			
			-- Animate the eye
			local conn = RunService.Heartbeat:Connect(function(dt)
				if weld and weld.Parent then
					weld.C0 = CFrame.new(0, 2 + math.sin(tick() * 2) * 0.3, 0)
				end
				if pw and pw.Parent then
					pw.C0 = CFrame.new(math.sin(tick() * 3) * 0.2, math.cos(tick() * 2) * 0.2, -0.5)
				end
			end)
			table.insert(ActiveEffects, conn)
		end
		
		-- Void tendrils on arms
		for _, arm in ipairs({rightArm, leftArm}) do
			if arm then
				local tendril = Instance.new("Part")
				tendril.Size = Vector3.new(0.3, 3, 0.3)
				tendril.Material = Enum.Material.Neon
				tendril.Color = creature.SecondaryColor
				tendril.CanCollide = false
				tendril.Massless = true
				tendril.Transparency = 0.3
				tendril.Parent = char
				
				local tw = Instance.new("Weld")
				tw.Part0 = arm
				tw.Part1 = tendril
				tw.C0 = CFrame.new(0, -1.5, 0)
				tw.Parent = tendril
				
				table.insert(MorphParts, tendril)
				
				local conn = RunService.Heartbeat:Connect(function()
					if tw and tw.Parent then
						tw.C0 = CFrame.new(math.sin(tick() * 4 + (arm == rightArm and 0 or math.pi)) * 0.3, -1.5, math.cos(tick() * 3) * 0.3)
							* CFrame.Angles(math.sin(tick() * 5) * 0.3, 0, math.cos(tick() * 4) * 0.2)
					end
				end)
				table.insert(ActiveEffects, conn)
			end
		end
		
	elseif creature.Name == "INFERNO TITAN" then
		-- Flame crown
		if head then
			for i = 1, 5 do
				local flame = Instance.new("Part")
				flame.Shape = Enum.PartType.Ball
				flame.Size = Vector3.new(0.4, 0.8, 0.4)
				flame.Material = Enum.Material.Neon
				flame.Color = creature.AccentColor
				flame.CanCollide = false
				flame.Massless = true
				flame.Transparency = 0.2
				flame.Parent = char
				
				local angle = (i / 5) * math.pi * 2
				local fw = Instance.new("Weld")
				fw.Part0 = head
				fw.Part1 = flame
				fw.C0 = CFrame.new(math.cos(angle) * 0.8, 0.8, math.sin(angle) * 0.8)
				fw.Parent = flame
				
				table.insert(MorphParts, flame)
				
				local pe = CreateParticleEffect(flame, creature.SecondaryColor, 30, 3, 0.5, 0.4, Enum.ParticleEmitterShape.Sphere, 0.3)
				pe.Name = "SVGMorphEffect"
			end
		end
		
		-- Lava drip from torso
		if torso then
			local pe = Instance.new("ParticleEmitter")
			pe.Name = "SVGMorphEffect"
			pe.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 200, 0)),
				ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255, 100, 0)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(150, 0, 0)),
			}
			pe.Rate = 15
			pe.Speed = NumberRange.new(0, 1)
			pe.Lifetime = NumberRange.new(1, 2)
			pe.Size = NumberSequence.new{
				NumberSequenceKeypoint.new(0, 0.5),
				NumberSequenceKeypoint.new(1, 0),
			}
			pe.Transparency = NumberSequence.new(0.2)
			pe.LightEmission = 1
			pe.SpreadAngle = Vector2.new(30, 30)
			pe.Acceleration = Vector3.new(0, -10, 0)
			pe.Parent = torso
			table.insert(ActiveEffects, pe)
		end
		
		-- Shoulder rocks
		for _, arm in ipairs({rightArm, leftArm}) do
			if arm then
				local rock = Instance.new("Part")
				rock.Size = Vector3.new(1.2, 0.8, 1)
				rock.Material = Enum.Material.Basalt
				rock.Color = Color3.fromRGB(60, 30, 10)
				rock.CanCollide = false
				rock.Massless = true
				rock.Parent = char
				
				local rw = Instance.new("Weld")
				rw.Part0 = arm
				rw.Part1 = rock
				rw.C0 = CFrame.new(arm == rightArm and 0.5 or -0.5, 0.5, 0) * CFrame.Angles(0, 0, math.rad(arm == rightArm and 20 or -20))
				rw.Parent = rock
				
				table.insert(MorphParts, rock)
				
				-- Glow in cracks
				local glowPE = CreateParticleEffect(rock, creature.AccentColor, 5, 0.5, 1, 0.2, Enum.ParticleEmitterShape.Sphere, 0.4)
				glowPE.Name = "SVGMorphEffect"
			end
		end
		
	elseif creature.Name == "GLITCH PHANTOM" then
		-- Glitch static overlay on all parts
		for _, part in ipairs(char:GetChildren()) do
			if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
				local pe = Instance.new("ParticleEmitter")
				pe.Name = "SVGMorphEffect"
				pe.Color = ColorSequence.new{
					ColorSequenceKeypoint.new(0, creature.Color),
					ColorSequenceKeypoint.new(0.5, creature.AccentColor),
					ColorSequenceKeypoint.new(1, creature.SecondaryColor),
				}
				pe.Rate = 8
				pe.Speed = NumberRange.new(0.5, 2)
				pe.Lifetime = NumberRange.new(0.1, 0.3)
				pe.Size = NumberSequence.new(0.3)
				pe.Transparency = NumberSequence.new(0.5)
				pe.LightEmission = 1
				pe.SpreadAngle = Vector2.new(180, 180)
				pe.Parent = part
				table.insert(ActiveEffects, pe)
			end
		end
		
		-- Glitch flicker effect
		local conn = RunService.Heartbeat:Connect(function()
			local char2 = GetCharacter()
			if char2 and math.random() < 0.05 then
				for _, part in ipairs(char2:GetChildren()) do
					if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
						local origTrans = part.Transparency
						part.Transparency = 0.8
						task.delay(0.05, function()
							if part and part.Parent then
								part.Transparency = origTrans
							end
						end)
					end
				end
			end
		end)
		table.insert(ActiveEffects, conn)
		
		-- Floating code blocks
		if head then
			for i = 1, 3 do
				local block = Instance.new("Part")
				block.Size = Vector3.new(0.5, 0.5, 0.5)
				block.Material = Enum.Material.Neon
				block.Color = i == 1 and creature.Color or (i == 2 and creature.SecondaryColor or creature.AccentColor)
				block.CanCollide = false
				block.Massless = true
				block.Transparency = 0.3
				block.Parent = char
				
				local bw = Instance.new("Weld")
				bw.Part0 = head
				bw.Part1 = block
				bw.Parent = block
				
				table.insert(MorphParts, block)
				
				local offset = i
				local conn2 = RunService.Heartbeat:Connect(function()
					if bw and bw.Parent then
						local t = tick() + offset * 2
						bw.C0 = CFrame.new(math.sin(t * 2) * 1.5, 1.5 + math.sin(t * 3) * 0.5, math.cos(t * 2) * 1.5)
							* CFrame.Angles(t * 3, t * 2, t * 4)
					end
				end)
				table.insert(ActiveEffects, conn2)
			end
		end
		
	elseif creature.Name == "BONE LEVIATHAN" then
		-- Spine protrusions on back
		if torso then
			for i = 1, 4 do
				local spine = Instance.new("Part")
				spine.Size = Vector3.new(0.3, 1.5 - (i * 0.2), 0.3)
				spine.Material = Enum.Material.SmoothPlastic
				spine.Color = Color3.fromRGB(230, 230, 210)
				spine.CanCollide = false
				spine.Massless = true
				spine.Parent = char
				
				local sw = Instance.new("Weld")
				sw.Part0 = torso
				sw.Part1 = spine
				sw.C0 = CFrame.new(0, 0.5 - (i * 0.3), -0.8) * CFrame.Angles(math.rad(-30), 0, 0)
				sw.Parent = spine
				
				table.insert(MorphParts, spine)
			end
		end
		
		-- Ghostly green aura
		if hrp then
			local pe = Instance.new("ParticleEmitter")
			pe.Name = "SVGMorphEffect"
			pe.Color = ColorSequence.new(creature.AccentColor)
			pe.Rate = 10
			pe.Speed = NumberRange.new(1, 3)
			pe.Lifetime = NumberRange.new(1, 2)
			pe.Size = NumberSequence.new{
				NumberSequenceKeypoint.new(0, 0),
				NumberSequenceKeypoint.new(0.5, 0.8),
				NumberSequenceKeypoint.new(1, 0),
			}
			pe.Transparency = NumberSequence.new(0.5)
			pe.LightEmission = 0.6
			pe.Acceleration = Vector3.new(0, 2, 0)
			pe.SpreadAngle = Vector2.new(180, 180)
			pe.Parent = hrp
			table.insert(ActiveEffects, pe)
		end
		
		-- Skull jaw extension
		if head then
			local jaw = Instance.new("Part")
			jaw.Size = Vector3.new(0.8, 0.3, 0.6)
			jaw.Material = Enum.Material.SmoothPlastic
			jaw.Color = Color3.fromRGB(230, 230, 210)
			jaw.CanCollide = false
			jaw.Massless = true
			jaw.Parent = char
			
			local jw = Instance.new("Weld")
			jw.Part0 = head
			jw.Part1 = jaw
			jw.C0 = CFrame.new(0, -0.7, -0.2)
			jw.Parent = jaw
			
			table.insert(MorphParts, jaw)
			
			local conn = RunService.Heartbeat:Connect(function()
				if jw and jw.Parent then
					jw.C0 = CFrame.new(0, -0.7 - math.abs(math.sin(tick() * 2)) * 0.15, -0.2) * CFrame.Angles(math.sin(tick() * 2) * 0.1, 0, 0)
				end
			end)
			table.insert(ActiveEffects, conn)
		end
		
	elseif creature.Name == "STATIC KING" then
		-- TV screen face
		if head then
			local screen = Instance.new("Part")
			screen.Size = Vector3.new(1.2, 1.2, 0.2)
			screen.Material = Enum.Material.Neon
			screen.Color = creature.Color
			screen.CanCollide = false
			screen.Massless = true
			screen.Transparency = 0.2
			screen.Parent = char
			
			local sw2 = Instance.new("Weld")
			sw2.Part0 = head
			sw2.Part1 = screen
			sw2.C0 = CFrame.new(0, 0, -0.5)
			sw2.Parent = screen
			
			table.insert(MorphParts, screen)
			
			-- Flicker the screen
			local conn = RunService.Heartbeat:Connect(function()
				if screen and screen.Parent then
					if math.random() < 0.1 then
						screen.Color = Color3.new(math.random(), math.random(), math.random())
					else
						screen.Color = creature.Color
					end
				end
			end)
			table.insert(ActiveEffects, conn)
		end
		
		-- Antenna
		if head then
			local antenna = Instance.new("Part")
			antenna.Size = Vector3.new(0.1, 1.5, 0.1)
			antenna.Material = Enum.Material.Metal
			antenna.Color = Color3.fromRGB(100, 100, 100)
			antenna.CanCollide = false
			antenna.Massless = true
			antenna.Parent = char
			
			local aw = Instance.new("Weld")
			aw.Part0 = head
			aw.Part1 = antenna
			aw.C0 = CFrame.new(0.3, 1, 0) * CFrame.Angles(0, 0, math.rad(15))
			aw.Parent = antenna
			
			table.insert(MorphParts, antenna)
			
			-- Antenna tip spark
			local tip = Instance.new("Part")
			tip.Shape = Enum.PartType.Ball
			tip.Size = Vector3.new(0.2, 0.2, 0.2)
			tip.Material = Enum.Material.Neon
			tip.Color = creature.SecondaryColor
			tip.CanCollide = false
			tip.Massless = true
			tip.Parent = char
			
			local tw2 = Instance.new("Weld")
			tw2.Part0 = antenna
			tw2.Part1 = tip
			tw2.C0 = CFrame.new(0, 0.75, 0)
			tw2.Parent = tip
			
			table.insert(MorphParts, tip)
			
			CreateParticleEffect(tip, creature.AccentColor, 15, 2, 0.3, 0.2, Enum.ParticleEmitterShape.Sphere, 0.3).Name = "SVGMorphEffect"
		end
		
		-- Static noise particles everywhere
		if hrp then
			local pe = Instance.new("ParticleEmitter")
			pe.Name = "SVGMorphEffect"
			pe.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
				ColorSequenceKeypoint.new(0.5, Color3.new(0.5, 0.5, 0.5)),
				ColorSequenceKeypoint.new(1, Color3.new(0, 0, 0)),
			}
			pe.Rate = 30
			pe.Speed = NumberRange.new(1, 5)
			pe.Lifetime = NumberRange.new(0.1, 0.4)
			pe.Size = NumberSequence.new(0.15)
			pe.Transparency = NumberSequence.new(0.4)
			pe.LightEmission = 0.5
			pe.SpreadAngle = Vector2.new(180, 180)
			pe.Parent = hrp
			table.insert(ActiveEffects, pe)
		end
	end
end

local function MorphInto(index)
	local creature = Creatures[index]
	if not creature then return end
	
	-- Clear existing morph
	if CurrentMorph then
		ClearMorph()
		task.wait(0.1)
	end
	
	local char = GetCharacter()
	local humanoid = GetHumanoid()
	local hrp = GetHRP()
	if not char or not humanoid or not hrp then return end
	
	CurrentMorph = index
	
	-- Morph transformation effect
	CreateExplosionEffect(hrp.Position, creature.Color, 15, 0.8)
	ShakeCamera(0.5, 0.3)
	FlashScreen(creature.Color, 0.3)
	
	-- Apply stats
	humanoid.WalkSpeed = creature.WalkSpeed
	humanoid.JumpPower = creature.JumpPower
	
	-- Apply body colors
	ApplyBodyColors(char, creature.BodyColors)
	
	-- Apply scale
	ApplyBodyScale(humanoid, creature.BodyScale)
	
	-- Apply decorations
	AddMorphDecorations(char, creature)
	
	-- Ring wave effect
	for i = 1, 3 do
		task.delay(i * 0.15, function()
			CreateRingEffect(hrp.Position, creature.Color, 20 + i * 5, 0.6)
		end)
	end
	
	-- Initialize cooldowns
	for _, ability in ipairs(creature.Abilities) do
		Cooldowns[ability.Key] = 0
	end
end

--------------------------------------------------------------------
-- ABILITY EXECUTION SYSTEM
--------------------------------------------------------------------

local function ExecuteSpinAttack(ability, creature)
	local char = GetCharacter()
	local hrp = GetHRP()
	if not char or not hrp then return end
	
	local target = GetClosestPlayer(ability.Range)
	if not target then return end
	
	IsAttacking = true
	
	local rightArm = char:FindFirstChild("Right Arm") or char:FindFirstChild("RightUpperArm")
	if not rightArm then IsAttacking = false return end
	
	-- Lunge toward target
	local direction = (target.HRP.Position - hrp.Position).Unit
	local bv = Instance.new("BodyVelocity")
	bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
	bv.Velocity = direction * 80
	bv.Parent = hrp
	Debris:AddItem(bv, 0.15)
	
	task.wait(0.15)
	
	-- HAND GOES INTO THE PLAYER AND SPINS AT INSANE SPEEDS
	local spinDuration = ability.Duration or 1
	local spinSpeed = ability.SpinSpeed or 80
	local startTime = tick()
	
	-- Lock position near target
	local lockBP = Instance.new("BodyPosition")
	lockBP.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
	lockBP.D = 500
	lockBP.P = 10000
	lockBP.Position = target.HRP.Position + direction * 2
	lockBP.Parent = hrp
	
	-- Create arm extension effect (hand going INTO the player)
	local drillPart = Instance.new("Part")
	drillPart.Size = Vector3.new(0.8, 0.8, 3)
	drillPart.Material = Enum.Material.Neon
	drillPart.Color = creature.AccentColor
	drillPart.CanCollide = false
	drillPart.Massless = true
	drillPart.Transparency = 0.3
	drillPart.Parent = workspace
	drillPart.Anchored = true
	
	-- Spinning particles
	local spinPE = CreateParticleEffect(drillPart, creature.Color, 100, 10, 0.3, 0.5, Enum.ParticleEmitterShape.Sphere, 0.2)
	local spinPE2 = CreateParticleEffect(drillPart, creature.AccentColor, 60, 8, 0.5, 0.8, Enum.ParticleEmitterShape.Sphere, 0.3)
	
	-- Blood/damage particles on target
	local damagePE = Instance.new("ParticleEmitter")
	damagePE.Color = ColorSequence.new(Color3.fromRGB(255, 0, 0))
	damagePE.Rate = 200
	damagePE.Speed = NumberRange.new(5, 15)
	damagePE.Lifetime = NumberRange.new(0.3, 0.8)
	damagePE.Size = NumberSequence.new(0.3)
	damagePE.SpreadAngle = Vector2.new(180, 180)
	damagePE.LightEmission = 0.3
	damagePE.Parent = target.HRP
	
	ShakeCamera(1.5, spinDuration)
	
	-- THE SPIN LOOP
	local spinAngle = 0
	local totalDamageDealt = 0
	local damageInterval = 0.1
	local lastDamage = 0
	
	local spinConn
	spinConn = RunService.Heartbeat:Connect(function(dt)
		local elapsed = tick() - startTime
		if elapsed >= spinDuration or not target.HRP or not target.HRP.Parent then
			spinConn:Disconnect()
			drillPart:Destroy()
			damagePE:Destroy()
			lockBP:Destroy()
			
			-- FINAL FLING
			if target.HRP and target.HRP.Parent then
				local flingDir = (target.HRP.Position - hrp.Position).Unit + Vector3.new(0, 1.5, 0)
				FlingTarget(target.HRP, 200, flingDir)
				DealDamage(target.Character, ability.Damage * 0.5)
				CreateExplosionEffect(target.HRP.Position, creature.AccentColor, 10, 0.5)
			end
			
			IsAttacking = false
			return
		end
		
		-- Spin the drill part at INSANE speeds
		spinAngle = spinAngle + dt * spinSpeed
		
		if target.HRP and target.HRP.Parent and hrp and hrp.Parent then
			local midPoint = (hrp.Position + target.HRP.Position) / 2
			drillPart.CFrame = CFrame.lookAt(hrp.Position, target.HRP.Position) 
				* CFrame.new(0, 0, -(hrp.Position - target.HRP.Position).Magnitude / 2)
				* CFrame.Angles(spinAngle, spinAngle * 0.7, spinAngle * 1.3)
			drillPart.Size = Vector3.new(0.8 + math.sin(spinAngle * 0.5) * 0.3, 0.8 + math.cos(spinAngle * 0.3) * 0.3, (hrp.Position - target.HRP.Position).Magnitude)
			
			lockBP.Position = target.HRP.Position + (hrp.Position - target.HRP.Position).Unit * 2
			
			-- Deal damage rapidly
			if tick() - lastDamage >= damageInterval then
				DealDamage(target.Character, ability.Damage * damageInterval / spinDuration)
				lastDamage = tick()
				
				-- Mini explosion effects
				local offset = Vector3.new(math.random(-2, 2), math.random(-2, 2), math.random(-2, 2))
				CreateExplosionEffect(target.HRP.Position + offset, creature.Color, 3, 0.2)
				
				-- Shake the target around
				local shakeBV = Instance.new("BodyVelocity")
				shakeBV.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
				shakeBV.Velocity = Vector3.new(math.random(-30, 30), math.random(-10, 30), math.random(-30, 30))
				shakeBV.Parent = target.HRP
				Debris:AddItem(shakeBV, 0.05)
			end
		end
	end)
end

local function ExecuteTeleport(ability, creature)
	local char = GetCharacter()
	local hrp = GetHRP()
	if not char or not hrp then return end
	
	local target = GetClosestPlayer(ability.Range)
	if not target then return end
	
	-- Vanish effect
	CreateExplosionEffect(hrp.Position, creature.Color, 8, 0.3)
	
	-- Make invisible briefly
	for _, part in ipairs(char:GetChildren()) do
		if part:IsA("BasePart") then
			part.Transparency = 1
		end
	end
	
	task.wait(0.2)
	
	-- Teleport behind target
	local behindPos = target.HRP.Position - target.HRP.CFrame.LookVector * 4
	hrp.CFrame = CFrame.new(behindPos, target.HRP.Position)
	
	-- Reappear
	for _, part in ipairs(char:GetChildren()) do
		if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
			part.Transparency = 0
		end
	end
	
	CreateExplosionEffect(hrp.Position, creature.AccentColor, 8, 0.3)
	FlashScreen(creature.Color, 0.15)
	
	task.wait(0.1)
	
	-- Strike!
	DealDamage(target.Character, ability.Damage)
	
	local flingDir = (target.HRP.Position - hrp.Position).Unit + Vector3.new(0, 0.5, 0)
	FlingTarget(target.HRP, 150, flingDir)
	
	CreateExplosionEffect(target.HRP.Position, Color3.fromRGB(255, 0, 0), 8, 0.4)
	ShakeCamera(0.8, 0.3)
end

local function ExecuteAOE(ability, creature)
	local char = GetCharacter()
	local hrp = GetHRP()
	if not char or not hrp then return end
	
	-- Windup
	ShakeCamera(0.3, 0.5)
	
	-- Ground slam animation (move down)
	local bv = Instance.new("BodyVelocity")
	bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
	bv.Velocity = Vector3.new(0, -50, 0)
	bv.Parent = hrp
	Debris:AddItem(bv, 0.2)
	
	task.wait(0.25)
	
	-- ERUPTION!
	ShakeCamera(2, 0.5)
	FlashScreen(creature.Color, 0.3)
	
	-- Multiple ring effects
	for i = 1, 5 do
		task.delay(i * 0.1, function()
			CreateRingEffect(hrp.Position, creature.Color, ability.Range * (i / 5), 0.5)
		end)
	end
	
	-- Pillar effects
	if creature.Name == "BONE LEVIATHAN" or creature.Name == "VOIDCRAWLER" then
		for i = 1, 8 do
			task.delay(i * 0.08, function()
				local angle = (i / 8) * math.pi * 2
				local pos = hrp.Position + Vector3.new(math.cos(angle) * (ability.Range * 0.6), 0, math.sin(angle) * (ability.Range * 0.6))
				
				local pillar = Instance.new("Part")
				pillar.Size = Vector3.new(2, 1, 2)
				pillar.Position = pos - Vector3.new(0, 5, 0)
				pillar.Anchored = true
				pillar.CanCollide = false
				pillar.Material = Enum.Material.Neon
				pillar.Color = creature.Color
				pillar.Transparency = 0.3
				pillar.Parent = workspace
				
				TweenService:Create(pillar, TweenInfo.new(0.3, Enum.EasingStyle.Expo, Enum.EasingDirection.Out), {
					Size = Vector3.new(2, 15, 2),
					Position = pos + Vector3.new(0, 5, 0),
				}):Play()
				
				task.delay(0.5, function()
					TweenService:Create(pillar, TweenInfo.new(0.5), {
						Transparency = 1,
						Size = Vector3.new(4, 15, 4),
					}):Play()
				end)
				
				Debris:AddItem(pillar, 1)
			end)
		end
	end
	
	-- Hit all nearby
	local nearby = GetNearbyPlayers(ability.Range)
	for _, target in ipairs(nearby) do
		DealDamage(target.Character, ability.Damage)
		
		local flingForce = ability.FlingForce or 400
		local flingDir
		if flingForce < 0 then
			-- Pull down
			flingDir = Vector3.new(0, -1, 0)
			flingForce = math.abs(flingForce)
		else
			flingDir = (target.HRP.Position - hrp.Position).Unit + Vector3.new(0, 1.5, 0)
		end
		FlingTarget(target.HRP, flingForce, flingDir)
		CreateExplosionEffect(target.HRP.Position, creature.AccentColor, 6, 0.4)
	end
	
	-- Central explosion
	CreateExplosionEffect(hrp.Position, creature.Color, 20, 0.6)
end

local function ExecuteGroundSlam(ability, creature)
	local char = GetCharacter()
	local hrp = GetHRP()
	if not char or not hrp then return end
	
	-- Jump up
	local jumpBV = Instance.new("BodyVelocity")
	jumpBV.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
	jumpBV.Velocity = Vector3.new(0, 100, 0)
	jumpBV.Parent = hrp
	Debris:AddItem(jumpBV, 0.3)
	
	task.wait(0.5)
	
	-- SLAM DOWN
	local slamBV = Instance.new("BodyVelocity")
	slamBV.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
	slamBV.Velocity = Vector3.new(0, -200, 0)
	slamBV.Parent = hrp
	Debris:AddItem(slamBV, 0.3)
	
	task.wait(0.3)
	
	-- Impact
	ShakeCamera(3, 0.8)
	FlashScreen(creature.AccentColor, 0.4)
	
	-- Fire pillars
	for i = 1, 12 do
		task.delay(i * 0.05, function()
			local angle = (i / 12) * math.pi * 2
			local dist = math.random(5, ability.Range)
			local pos = hrp.Position + Vector3.new(math.cos(angle) * dist, 0, math.sin(angle) * dist)
			
			local pillar = Instance.new("Part")
			pillar.Size = Vector3.new(3, 1, 3)
			pillar.Position = pos
			pillar.Anchored = true
			pillar.CanCollide = false
			pillar.Material = Enum.Material.Neon
			pillar.Color = creature.Color
			pillar.Transparency = 0.2
			pillar.Parent = workspace
			
			CreateParticleEffect(pillar, creature.AccentColor, 50, 10, 0.5, 1, Enum.ParticleEmitterShape.Sphere, 0.2)
			
			TweenService:Create(pillar, TweenInfo.new(0.4, Enum.EasingStyle.Expo, Enum.EasingDirection.Out), {
				Size = Vector3.new(3, 20, 3),
				Position = pos + Vector3.new(0, 10, 0),
			}):Play()
			
			task.delay(0.8, function()
				TweenService:Create(pillar, TweenInfo.new(0.5), {
					Transparency = 1,
				}):Play()
			end)
			
			Debris:AddItem(pillar, 1.5)
		end)
	end
	
	-- Ring effects
	for i = 1, 4 do
		task.delay(i * 0.12, function()
			CreateRingEffect(hrp.Position, creature.Color, ability.Range * (i / 4), 0.7)
		end)
	end
	
	-- Damage
	local nearby = GetNearbyPlayers(ability.Range)
	for _, target in ipairs(nearby) do
		DealDamage(target.Character, ability.Damage)
		local flingDir = (target.HRP.Position - hrp.Position).Unit + Vector3.new(0, 2, 0)
		FlingTarget(target.HRP, ability.FlingForce or 500, flingDir)
		CreateExplosionEffect(target.HRP.Position, Color3.fromRGB(255, 100, 0), 8, 0.4)
	end
	
	CreateExplosionEffect(hrp.Position, creature.Color, 25, 0.8)
end

local function ExecuteProjectile(ability, creature)
	local char = GetCharacter()
	local hrp = GetHRP()
	if not char or not hrp then return end
	
	local mousePos = Mouse.Hit.Position
	
	for i = 1, (ability.Count or 5) do
		task.delay(i * 0.3, function()
			if not hrp or not hrp.Parent then return end
			
			local spawnPos = mousePos + Vector3.new(math.random(-15, 15), 60 + math.random(0, 20), math.random(-15, 15))
			local targetPos = mousePos + Vector3.new(math.random(-8, 8), 0, math.random(-8, 8))
			
			local meteor = Instance.new("Part")
			meteor.Shape = Enum.PartType.Ball
			meteor.Size = Vector3.new(4, 4, 4)
			meteor.Position = spawnPos
			meteor.Material = Enum.Material.Neon
			meteor.Color = creature.Color
			meteor.Anchored = false
			meteor.CanCollide = false
			meteor.Parent = workspace
			
			CreateParticleEffect(meteor, creature.AccentColor, 80, 5, 0.5, 1.5, Enum.ParticleEmitterShape.Sphere, 0.2)
			
			local light = Instance.new("PointLight")
			light.Color = creature.Color
			light.Brightness = 5
			light.Range = 20
			light.Parent = meteor
			
			-- Fire it down
			local bv2 = Instance.new("BodyVelocity")
			bv2.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
			bv2.Velocity = (targetPos - spawnPos).Unit * 120
			bv2.Parent = meteor
			
			-- Check for impact
			local impacted = false
			meteor.Touched:Connect(function(hit)
				if impacted then return end
				if hit:IsDescendantOf(char) then return end
				impacted = true
				
				CreateExplosionEffect(meteor.Position, creature.Color, 15, 0.5)
				ShakeCamera(1, 0.2)
				
				-- Damage nearby
				for _, p in ipairs(Players:GetPlayers()) do
					if p ~= Player and p.Character then
						local otherHRP = p.Character:FindFirstChild("HumanoidRootPart")
						if otherHRP and (otherHRP.Position - meteor.Position).Magnitude <= 12 then
							DealDamage(p.Character, ability.Damage)
							local fDir = (otherHRP.Position - meteor.Position).Unit + Vector3.new(0, 1, 0)
							FlingTarget(otherHRP, 200, fDir)
						end
					end
				end
				
				meteor:Destroy()
			end)
			
			Debris:AddItem(meteor, 5)
		end)
	end
end

local function ExecuteStun(ability, creature)
	local char = GetCharacter()
	local hrp = GetHRP()
	if not char or not hrp then return end
	
	local nearby = GetNearbyPlayers(ability.Range)
	if #nearby == 0 then return end
	
	-- Eye opening effect
	FlashScreen(creature.AccentColor, 0.5)
	ShakeCamera(0.5, 0.3)
	
	-- Create stun zone
	local zone = Instance.new("Part")
	zone.Shape = Enum.PartType.Ball
	zone.Size = Vector3.new(1, 1, 1)
	zone.Position = hrp.Position
	zone.Anchored = true
	zone.CanCollide = false
	zone.Material = Enum.Material.ForceField
	zone.Color = creature.Color
	zone.Transparency = 0.7
	zone.Parent = workspace
	
	TweenService:Create(zone, TweenInfo.new(0.5, Enum.EasingStyle.Expo, Enum.EasingDirection.Out), {
		Size = Vector3.new(ability.Range * 2, ability.Range * 2, ability.Range * 2),
	}):Play()
	
	-- DPS over duration
	local duration2 = ability.Duration or 3
	local dps = ability.DPS or 10
	local startTime = tick()
	
	local conn2
	conn2 = RunService.Heartbeat:Connect(function(dt)
		local elapsed = tick() - startTime
		if elapsed >= duration2 then
			conn2:Disconnect()
			TweenService:Create(zone, TweenInfo.new(0.3), {Transparency = 1}):Play()
			Debris:AddItem(zone, 0.3)
			return
		end
		
		zone.Position = hrp.Position
		
		-- Freeze and damage nearby
		for _, target in ipairs(GetNearbyPlayers(ability.Range)) do
			-- Slow them
			local hum = target.Character:FindFirstChildOfClass("Humanoid")
			if hum then
				hum.WalkSpeed = 2
				hum.JumpPower = 0
			end
			
			DealDamage(target.Character, dps * dt)
			
			-- Visual effect on stunned players
			if math.random() < 0.3 then
				CreateExplosionEffect(target.HRP.Position + Vector3.new(math.random(-2, 2), math.random(-1, 2), math.random(-2, 2)), creature.AccentColor, 2, 0.2)
			end
		end
	end)
	
	-- Restore speeds after duration
	task.delay(duration2 + 0.1, function()
		for _, target in ipairs(GetNearbyPlayers(ability.Range + 10)) do
			local hum = target.Character:FindFirstChildOfClass("Humanoid")
			if hum then
				hum.WalkSpeed = 16
				hum.JumpPower = 50
			end
		end
	end)
end

local function ExecuteDash(ability, creature)
	local char = GetCharacter()
	local hrp = GetHRP()
	if not char or not hrp then return end
	
	local direction = hrp.CFrame.LookVector
	local dashDist = ability.Range or 60
	local afterimages = ability.Afterimages or 5
	local segmentDist = dashDist / afterimages
	
	for i = 1, afterimages do
		-- Create afterimage
		local ghost = Instance.new("Part")
		ghost.Size = Vector3.new(2, 5, 1)
		ghost.CFrame = hrp.CFrame
		ghost.Anchored = true
		ghost.CanCollide = false
		ghost.Material = Enum.Material.Neon
		ghost.Color = i % 2 == 0 and creature.Color or creature.AccentColor
		ghost.Transparency = 0.5
		ghost.Parent = workspace
		
		CreateParticleEffect(ghost, creature.SecondaryColor, 30, 3, 0.5, 0.5, Enum.ParticleEmitterShape.Sphere, 0.4)
		
		-- Afterimage damages
		local damaged = {}
		ghost.Touched:Connect(function(hit)
			local p = Players:GetPlayerFromCharacter(hit.Parent)
			if p and p ~= Player and not damaged[p] then
				damaged[p] = true
				DealDamage(hit.Parent, ability.Damage)
				CreateExplosionEffect(hit.Position, creature.AccentColor, 5, 0.3)
			end
		end)
		
		TweenService:Create(ghost, TweenInfo.new(1.5), {
			Transparency = 1,
			Size = Vector3.new(4, 7, 3),
		}):Play()
		
		Debris:AddItem(ghost, 1.5)
		
		-- Teleport forward
		hrp.CFrame = hrp.CFrame + direction * segmentDist
		CreateExplosionEffect(hrp.Position, creature.Color, 5, 0.2)
		
		task.wait(0.04)
	end
	
	FlashScreen(creature.Color, 0.2)
end

local function ExecuteSwarm(ability, creature)
	local char = GetCharacter()
	local hrp = GetHRP()
	if not char or not hrp then return end
	
	local count = ability.Count or 30
	
	-- Create swarming pixels
	for i = 1, count do
		task.delay(i * 0.02, function()
			if not hrp or not hrp.Parent then return end
			
			local pixel = Instance.new("Part")
			pixel.Size = Vector3.new(0.5, 0.5, 0.5)
			pixel.Position = hrp.Position + Vector3.new(math.random(-3, 3), math.random(-2, 3), math.random(-3, 3))
			pixel.Anchored = false
			pixel.CanCollide = false
			pixel.Material = Enum.Material.Neon
			pixel.Color = Color3.new(math.random(), math.random(), math.random())
			pixel.Parent = workspace
			
			-- Find target
			local target = GetClosestPlayer(ability.Range)
			if target and target.HRP then
				local dir = (target.HRP.Position - pixel.Position).Unit
				local bv3 = Instance.new("BodyVelocity")
				bv3.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
				bv3.Velocity = dir * (30 + math.random(0, 30))
				bv3.Parent = pixel
				
				pixel.Touched:Connect(function(hit)
					local p = Players:GetPlayerFromCharacter(hit.Parent)
					if p and p ~= Player then
						DealDamage(hit.Parent, ability.Damage)
						pixel:Destroy()
					end
				end)
			else
				-- Random spread
				local bv3 = Instance.new("BodyVelocity")
				bv3.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
				bv3.Velocity = Vector3.new(math.random(-30, 30), math.random(-10, 20), math.random(-30, 30))
				bv3.Parent = pixel
			end
			
			Debris:AddItem(pixel, 3)
		end)
	end
	
	ShakeCamera(0.3, 0.5)
end

local function ExecuteScreenEffect(ability, creature)
	local char = GetCharacter()
	local hrp = GetHRP()
	if not char or not hrp then return end
	
	-- Big pulse
	CreateExplosionEffect(hrp.Position, creature.Color, 40, 1)
	ShakeCamera(2, ability.Duration or 3)
	
	for i = 1, 5 do
		task.delay(i * 0.2, function()
			CreateRingEffect(hrp.Position, creature.AccentColor, ability.Range, 0.8)
		end)
	end
	
	-- Damage all nearby
	local nearby = GetNearbyPlayers(ability.Range)
	for _, target in ipairs(nearby) do
		DealDamage(target.Character, ability.Damage)
		
		-- Fling
		local fDir = (target.HRP.Position - hrp.Position).Unit + Vector3.new(0, 1, 0)
		FlingTarget(target.HRP, 300, fDir)
		
		-- Create error text above them
		for j = 1, 5 do
			task.delay(j * 0.2, function()
				if target.HRP and target.HRP.Parent then
					local billboard = Instance.new("BillboardGui")
					billboard.Size = UDim2.new(4, 0, 1, 0)
					billboard.StudsOffset = Vector3.new(math.random(-3, 3), 3 + j, 0)
					billboard.Adornee = target.HRP
					billboard.Parent = target.HRP
					
					local text = Instance.new("TextLabel")
					text.Size = UDim2.new(1, 0, 1, 0)
					text.BackgroundTransparency = 1
					text.Text = ({"ERROR", "FATAL", "0x00FF", "CRASH", "BSOD", "NULL", "VOID"})[math.random(1, 7)]
					text.TextColor3 = creature.AccentColor
					text.TextScaled = true
					text.Font = Enum.Font.Code
					text.Parent = billboard
					
					Debris:AddItem(billboard, 2)
				end
			end)
		end
	end
end

local function ExecuteMultiTeleport(ability, creature)
	local char = GetCharacter()
	local hrp = GetHRP()
	if not char or not hrp then return end
	
	local strikes = ability.Strikes or 5
	local nearby = GetNearbyPlayers(ability.Range)
	if #nearby == 0 then return end
	
	for i = 1, strikes do
		task.delay((i - 1) * 0.25, function()
			if not hrp or not hrp.Parent then return end
			
			local target = nearby[math.random(1, #nearby)]
			if not target.HRP or not target.HRP.Parent then return end
			
			-- Vanish
			CreateExplosionEffect(hrp.Position, creature.Color, 5, 0.2)
			
			-- Teleport to random position near target
			local angle = math.random() * math.pi * 2
			local offset = Vector3.new(math.cos(angle) * 3, 0, math.sin(angle) * 3)
			hrp.CFrame = CFrame.new(target.HRP.Position + offset, target.HRP.Position)
			
			-- Appear
			CreateExplosionEffect(hrp.Position, creature.AccentColor, 5, 0.2)
			FlashScreen(creature.Color, 0.05)
			
			-- Strike
			DealDamage(target.Character, ability.Damage)
			
			if i == strikes then
				-- Final fling
				local fDir = (target.HRP.Position - hrp.Position).Unit + Vector3.new(0, 1, 0)
				FlingTarget(target.HRP, 200, fDir)
				ShakeCamera(1, 0.3)
			end
		end)
	end
end

local function ExecuteZone(ability, creature)
	local char = GetCharacter()
	local hrp = GetHRP()
	if not char or not hrp then return end
	
	local zone = Instance.new("Part")
	zone.Shape = Enum.PartType.Cylinder
	zone.Size = Vector3.new(2, ability.Range * 2, ability.Range * 2)
	zone.CFrame = CFrame.new(hrp.Position) * CFrame.Angles(0, 0, math.rad(90))
	zone.Anchored = true
	zone.CanCollide = false
	zone.Material = Enum.Material.ForceField
	zone.Color = creature.Color
	zone.Transparency = 0.7
	zone.Parent = workspace
	
	-- Static particles
	local pe = Instance.new("ParticleEmitter")
	pe.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
		ColorSequenceKeypoint.new(0.5, creature.Color),
		ColorSequenceKeypoint.new(1, Color3.new(0, 0, 0)),
	}
	pe.Rate = 100
	pe.Speed = NumberRange.new(2, 8)
	pe.Lifetime = NumberRange.new(0.2, 0.5)
	pe.Size = NumberSequence.new(0.3)
	pe.SpreadAngle = Vector2.new(180, 180)
	pe.LightEmission = 0.5
	pe.Parent = zone
	
	local duration3 = ability.Duration or 5
	local dps = ability.DPS or 10
	local startTime = tick()
	local zonePos = hrp.Position
	
	local conn3
	conn3 = RunService.Heartbeat:Connect(function(dt)
		if tick() - startTime >= duration3 then
			conn3:Disconnect()
			TweenService:Create(zone, TweenInfo.new(0.5), {Transparency = 1}):Play()
			Debris:AddItem(zone, 0.5)
			return
		end
		
		-- Flicker zone
		if math.random() < 0.1 then
			zone.Color = Color3.new(math.random(), math.random(), math.random())
		else
			zone.Color = creature.Color
		end
		
		-- Damage enemies in zone
		for _, p in ipairs(Players:GetPlayers()) do
			if p ~= Player and p.Character then
				local otherHRP = p.Character:FindFirstChild("HumanoidRootPart")
				if otherHRP and (otherHRP.Position - zonePos).Magnitude <= ability.Range then
					DealDamage(p.Character, dps * dt)
					
					-- Slow
					local hum = p.Character:FindFirstChildOfClass("Humanoid")
					if hum then
						hum.WalkSpeed = 6
					end
				end
			end
		end
	end)
	
	task.delay(duration3, function()
		for _, p in ipairs(Players:GetPlayers()) do
			if p ~= Player and p.Character then
				local hum = p.Character:FindFirstChildOfClass("Humanoid")
				if hum then
					hum.WalkSpeed = 16
				end
			end
		end
	end)
end

local function ExecuteTrap(ability, creature)
	local char = GetCharacter()
	local hrp = GetHRP()
	if not char or not hrp then return end
	
	local nearby = GetNearbyPlayers(ability.Range)
	
	for _, target in ipairs(nearby) do
		if target.HRP and target.HRP.Parent then
			-- Create bone cage
			local cageCenter = target.HRP.Position
			local bones = {}
			
			for i = 1, 8 do
				local angle = (i / 8) * math.pi * 2
				local bonePos = cageCenter + Vector3.new(math.cos(angle) * 4, -3, math.sin(angle) * 4)
				
				local bone = Instance.new("Part")
				bone.Size = Vector3.new(1, 1, 1)
				bone.Position = bonePos
				bone.Anchored = true
				bone.CanCollide = true
				bone.Material = Enum.Material.SmoothPlastic
				bone.Color = Color3.fromRGB(230, 230, 210)
				bone.Parent = workspace
				
				TweenService:Create(bone, TweenInfo.new(0.3, Enum.EasingStyle.Expo, Enum.EasingDirection.Out), {
					Size = Vector3.new(1, 12, 1),
					Position = bonePos + Vector3.new(0, 6, 0),
				}):Play()
				
				table.insert(bones, bone)
			end
			
			-- Lock target
			local lockBP2 = Instance.new("BodyPosition")
			lockBP2.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
			lockBP2.Position = cageCenter
			lockBP2.D = 300
			lockBP2.P = 5000
			lockBP2.Parent = target.HRP
			
			-- Crush inward over duration
			local duration4 = ability.Duration or 4
			local startTime = tick()
			
			local crushConn
			crushConn = RunService.Heartbeat:Connect(function(dt)
				local elapsed = tick() - startTime
				if elapsed >= duration4 then
					crushConn:Disconnect()
					lockBP2:Destroy()
					for _, b in ipairs(bones) do
						CreateExplosionEffect(b.Position, creature.AccentColor, 5, 0.3)
						b:Destroy()
					end
					-- Final damage + fling
					if target.HRP and target.HRP.Parent then
						DealDamage(target.Character, ability.Damage)
						FlingTarget(target.HRP, 300, Vector3.new(0, 2, 0))
					end
					return
				end
				
				-- DPS
				DealDamage(target.Character, (ability.Damage * 0.3) * dt / duration4)
				
				-- Crush bones inward
				local crushFactor = elapsed / duration4
				for idx, b in ipairs(bones) do
					if b and b.Parent then
						local angle2 = (idx / 8) * math.pi * 2
						local newDist = 4 * (1 - crushFactor * 0.7)
						b.Position = cageCenter + Vector3.new(math.cos(angle2) * newDist, 3, math.sin(angle2) * newDist)
					end
				end
			end)
		end
	end
	
	ShakeCamera(0.5, 0.3)
	FlashScreen(creature.AccentColor, 0.2)
end

local function ExecuteBeam(ability, creature)
	local char = GetCharacter()
	local hrp = GetHRP()
	if not char or not hrp then return end
	
	local direction = hrp.CFrame.LookVector
	local endPos = hrp.Position + direction * (ability.Range or 100)
	
	-- Charge up
	for i = 1, 5 do
		task.wait(0.05)
		CreateExplosionEffect(hrp.Position + direction * 2, creature.Color, 3 + i, 0.2)
	end
	
	-- FIRE BEAM
	ShakeCamera(1.5, 0.5)
	FlashScreen(creature.AccentColor, 0.3)
	
	-- Create beam
	CreateBeamEffect(hrp.Position + direction * 2, endPos, creature.Color, ability.Width or 4, 0.8)
	CreateBeamEffect(hrp.Position + direction * 2, endPos, creature.AccentColor, (ability.Width or 4) * 0.5, 1)
	
	-- Damage everything along the beam
	for _, p in ipairs(Players:GetPlayers()) do
		if p ~= Player and p.Character then
			local otherHRP = p.Character:FindFirstChild("HumanoidRootPart")
			if otherHRP then
				-- Check if near beam line
				local toTarget = otherHRP.Position - hrp.Position
				local projected = toTarget:Dot(direction)
				if projected > 0 and projected < ability.Range then
					local closestPoint = hrp.Position + direction * projected
					local distFromBeam = (otherHRP.Position - closestPoint).Magnitude
					if distFromBeam <= (ability.Width or 4) * 2 then
						DealDamage(p.Character, ability.Damage)
						local fDir = direction + Vector3.new(0, 0.5, 0)
						FlingTarget(otherHRP, 250, fDir)
						CreateExplosionEffect(otherHRP.Position, Color3.fromRGB(255, 0, 0), 8, 0.4)
					end
				end
			end
		end
	end
	
	-- Impact explosion at end
	CreateExplosionEffect(endPos, creature.Color, 15, 0.6)
end

local function ExecuteAura(ability, creature)
	local char = GetCharacter()
	local hrp = GetHRP()
	if not char or not hrp then return end
	
	local duration5 = ability.Duration or 5
	local dps = ability.DPS or 8
	local startTime = tick()
	
	-- Create aura visual
	local aura = Instance.new("Part")
	aura.Shape = Enum.PartType.Ball
	aura.Size = Vector3.new(ability.Range * 2, ability.Range * 2, ability.Range * 2)
	aura.Position = hrp.Position
	aura.Anchored = true
	aura.CanCollide = false
	aura.Material = Enum.Material.ForceField
	aura.Color = creature.Color
	aura.Transparency = 0.85
	aura.Parent = workspace
	
	local pe = CreateParticleEffect(aura, creature.AccentColor, 50, 3, 1, 1, Enum.ParticleEmitterShape.Sphere, 0.4)
	
	local conn4
	conn4 = RunService.Heartbeat:Connect(function(dt)
		if tick() - startTime >= duration5 or not hrp or not hrp.Parent then
			conn4:Disconnect()
			aura:Destroy()
			return
		end
		
		aura.Position = hrp.Position
		
		-- Pulse effect
		local pulse = math.sin(tick() * 5) * 0.1
		aura.Size = Vector3.new(ability.Range * 2 * (1 + pulse), ability.Range * 2 * (1 + pulse), ability.Range * 2 * (1 + pulse))
		aura.Transparency = 0.85 + pulse
		
		-- Damage nearby
		for _, p in ipairs(Players:GetPlayers()) do
			if p ~= Player and p.Character then
				local otherHRP = p.Character:FindFirstChild("HumanoidRootPart")
				if otherHRP and (otherHRP.Position - hrp.Position).Magnitude <= ability.Range then
					DealDamage(p.Character, dps * dt)
					
					-- Fire particles on them
					if math.random() < 0.2 then
						CreateExplosionEffect(otherHRP.Position, creature.AccentColor, 3, 0.3)
					end
				end
			end
		end
	end)
	
	ShakeCamera(0.3, duration5)
end

local function ExecuteUltimate(ability, creature)
	local char = GetCharacter()
	local hrp = GetHRP()
	if not char or not hrp then return end
	
	-- MASSIVE WINDUP
	ShakeCamera(1, 1)
	
	-- Charging effect
	for i = 1, 10 do
		task.delay(i * 0.1, function()
			if not hrp or not hrp.Parent then return end
			CreateRingEffect(hrp.Position, creature.Color, 5 + i * 2, 0.3)
			CreateExplosionEffect(hrp.Position, creature.AccentColor, 3 + i, 0.2)
		end)
	end
	
	task.wait(1.2)
	
	-- THE BLAST
	ShakeCamera(4, 1)
	FlashScreen(Color3.new(1, 1, 1), 0.5)
	
	-- Massive explosion
	CreateExplosionEffect(hrp.Position, creature.Color, 50, 1.5)
	CreateExplosionEffect(hrp.Position, creature.AccentColor, 40, 1)
	CreateExplosionEffect(hrp.Position, Color3.new(1, 1, 1), 30, 0.8)
	
	-- Ring waves
	for i = 1, 8 do
		task.delay(i * 0.1, function()
			CreateRingEffect(hrp.Position, i % 2 == 0 and creature.Color or creature.AccentColor, ability.Range * (i / 8), 1)
		end)
	end
	
	-- Pillar of energy
	local pillar = Instance.new("Part")
	pillar.Size = Vector3.new(8, 1, 8)
	pillar.Position = hrp.Position
	pillar.Anchored = true
	pillar.CanCollide = false
	pillar.Material = Enum.Material.Neon
	pillar.Color = creature.Color
	pillar.Transparency = 0.3
	pillar.Parent = workspace
	
	TweenService:Create(pillar, TweenInfo.new(0.5, Enum.EasingStyle.Expo, Enum.EasingDirection.Out), {
		Size = Vector3.new(8, 200, 8),
		Position = hrp.Position + Vector3.new(0, 100, 0),
	}):Play()
	
	task.delay(1, function()
		TweenService:Create(pillar, TweenInfo.new(0.5), {Transparency = 1}):Play()
	end)
	Debris:AddItem(pillar, 2)
	
	-- DAMAGE EVERYONE
	local nearby = GetNearbyPlayers(ability.Range)
	for _, target in ipairs(nearby) do
		DealDamage(target.Character, ability.Damage)
		local fDir = (target.HRP.Position - hrp.Position).Unit + Vector3.new(0, 2, 0)
		FlingTarget(target.HRP, ability.FlingForce or 500, fDir)
		
		-- Individual explosion on each target
		CreateExplosionEffect(target.HRP.Position, creature.AccentColor, 12, 0.5)
		
		-- Error text for Static King
		if creature.Name == "STATIC KING" then
			for j = 1, 3 do
				task.delay(j * 0.15, function()
					if target.HRP and target.HRP.Parent then
						local bb = Instance.new("BillboardGui")
						bb.Size = UDim2.new(6, 0, 1.5, 0)
						bb.StudsOffset = Vector3.new(0, 3 + j * 1.5, 0)
						bb.Adornee = target.HRP
						bb.Parent = target.HRP
						
						local txt = Instance.new("TextLabel")
						txt.Size = UDim2.new(1, 0, 1, 0)
						txt.BackgroundTransparency = 1
						txt.Text = "‚ö†Ô∏è EMERGENCY BROADCAST ‚ö†Ô∏è"
						txt.TextColor3 = Color3.new(1, 0, 0)
						txt.TextScaled = true
						txt.Font = Enum.Font.Code
						txt.Parent = bb
						
						Debris:AddItem(bb, 3)
					end
				end)
			end
		end
	end
end

--------------------------------------------------------------------
-- ABILITY ROUTER
--------------------------------------------------------------------
local function UseAbility(abilityIndex)
	if not CurrentMorph then return end
	if IsAttacking then return end
	
	local creature = Creatures[CurrentMorph]
	local ability = creature.Abilities[abilityIndex]
	if not ability then return end
	
	-- Check cooldown
	local now = tick()
	if Cooldowns[ability.Key] and now < Cooldowns[ability.Key] then
		return
	end
	
	-- Set cooldown
	Cooldowns[ability.Key] = now + ability.Cooldown
	
	-- Route to handler
	local abilityType = ability.Type
	
	task.spawn(function()
		if abilityType == "SpinAttack" then
			ExecuteSpinAttack(ability, creature)
		elseif abilityType == "Teleport" then
			ExecuteTeleport(ability, creature)
		elseif abilityType == "AOE" then
			ExecuteAOE(ability, creature)
		elseif abilityType == "Stun" then
			ExecuteStun(ability, creature)
		elseif abilityType == "GroundSlam" then
			ExecuteGroundSlam(ability, creature)
		elseif abilityType == "Projectile" then
			ExecuteProjectile(ability, creature)
		elseif abilityType == "Dash" then
			ExecuteDash(ability, creature)
		elseif abilityType == "Swarm" then
			ExecuteSwarm(ability, creature)
		elseif abilityType == "ScreenEffect" then
			ExecuteScreenEffect(ability, creature)
		elseif abilityType == "MultiTeleport" then
			ExecuteMultiTeleport(ability, creature)
		elseif abilityType == "Zone" then
			ExecuteZone(ability, creature)
		elseif abilityType == "Trap" then
			ExecuteTrap(ability, creature)
		elseif abilityType == "Beam" then
			ExecuteBeam(ability, creature)
		elseif abilityType == "Aura" then
			ExecuteAura(ability, creature)
		elseif abilityType == "Ultimate" then
			ExecuteUltimate(ability, creature)
		end
	end)
end

--------------------------------------------------------------------
-- USER INTERFACE
--------------------------------------------------------------------

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "SVGBobMorphMenu"
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.Parent = Player:WaitForChild("PlayerGui")

-- Toggle button
local ToggleButton = Instance.new("TextButton")
ToggleButton.Name = "ToggleBtn"
ToggleButton.Size = UDim2.new(0, 50, 0, 50)
ToggleButton.Position = UDim2.new(0, 15, 0.5, -25)
ToggleButton.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
ToggleButton.TextColor3 = Color3.fromRGB(255, 0, 100)
ToggleButton.Text = "SVG"
ToggleButton.TextScaled = true
ToggleButton.Font = Enum.Font.GothamBold
ToggleButton.Parent = ScreenGui
ToggleButton.BorderSizePixel = 0
ToggleButton.AutoButtonColor = false

local toggleCorner = Instance.new("UICorner")
toggleCorner.CornerRadius = UDim.new(0.5, 0)
toggleCorner.Parent = ToggleButton

local toggleStroke = Instance.new("UIStroke")
toggleStroke.Color = Color3.fromRGB(255, 0, 100)
toggleStroke.Thickness = 2
toggleStroke.Parent = ToggleButton

-- Pulse animation on toggle button
task.spawn(function()
	while true do
		TweenService:Create(toggleStroke, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
			Color = Color3.fromRGB(100, 0, 255)
		}):Play()
		task.wait(1)
		TweenService:Create(toggleStroke, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
			Color = Color3.fromRGB(255, 0, 100)
		}):Play()
		task.wait(1)
	end
end)

-- Main frame
local MainFrame = Instance.new("Frame")
MainFrame.Name = "MainFrame"
MainFrame.Size = UDim2.new(0, 550, 0, 520)
MainFrame.Position = UDim2.new(0.5, -275, 0.5, -260)
MainFrame.BackgroundColor3 = Color3.fromRGB(12, 12, 18)
MainFrame.BorderSizePixel = 0
MainFrame.Visible = false
MainFrame.Parent = ScreenGui
MainFrame.ClipsDescendants = true

local mainCorner = Instance.new("UICorner")
mainCorner.CornerRadius = UDim.new(0, 16)
mainCorner.Parent = MainFrame

local mainStroke = Instance.new("UIStroke")
mainStroke.Color = Color3.fromRGB(255, 0, 100)
mainStroke.Thickness = 2
mainStroke.Transparency = 0.3
mainStroke.Parent = MainFrame

-- Background gradient
local gradient = Instance.new("UIGradient")
gradient.Color = ColorSequence.new{
	ColorSequenceKeypoint.new(0, Color3.fromRGB(12, 12, 18)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(25, 5, 30)),
}
gradient.Rotation = 135
gradient.Parent = MainFrame

-- Title bar
local TitleBar = Instance.new("Frame")
TitleBar.Size = UDim2.new(1, 0, 0, 50)
TitleBar.BackgroundColor3 = Color3.fromRGB(18, 18, 25)
TitleBar.BorderSizePixel = 0
TitleBar.Parent = MainFrame

local titleCorner = Instance.new("UICorner")
titleCorner.CornerRadius = UDim.new(0, 16)
titleCorner.Parent = TitleBar

local TitleText = Instance.new("TextLabel")
TitleText.Size = UDim2.new(1, -20, 1, 0)
TitleText.Position = UDim2.new(0, 10, 0, 0)
TitleText.BackgroundTransparency = 1
TitleText.Text = "üëÅÔ∏è SVG BOB'S UNHINGED MORPH MENU üëÅÔ∏è"
TitleText.TextColor3 = Color3.fromRGB(255, 50, 120)
TitleText.TextScaled = true
TitleText.Font = Enum.Font.GothamBold
TitleText.Parent = TitleBar

-- Animate title color
task.spawn(function()
	local hue = 0
	while true do
		hue = (hue + 0.005) % 1
		TitleText.TextColor3 = Color3.fromHSV(hue, 1, 1)
		mainStroke.Color = Color3.fromHSV(hue, 1, 1)
		task.wait()
	end
end)

-- Creature cards container
local CardContainer = Instance.new("ScrollingFrame")
CardContainer.Name = "Cards"
CardContainer.Size = UDim2.new(1, -20, 0, 350)
CardContainer.Position = UDim2.new(0, 10, 0, 55)
CardContainer.BackgroundTransparency = 1
CardContainer.ScrollBarThickness = 4
CardContainer.ScrollBarImageColor3 = Color3.fromRGB(255, 0, 100)
CardContainer.CanvasSize = UDim2.new(0, 0, 0, 0)
CardContainer.AutomaticCanvasSize = Enum.AutomaticSize.Y
CardContainer.Parent = MainFrame

local cardLayout = Instance.new("UIListLayout")
cardLayout.Padding = UDim.new(0, 8)
cardLayout.FillDirection = Enum.FillDirection.Vertical
cardLayout.Parent = CardContainer

-- Unmorphing button
local UnmorphButton = Instance.new("TextButton")
UnmorphButton.Size = UDim2.new(1, -20, 0, 40)
UnmorphButton.Position = UDim2.new(0, 10, 1, -50)
UnmorphButton.BackgroundColor3 = Color3.fromRGB(80, 0, 0)
UnmorphButton.TextColor3 = Color3.fromRGB(255, 100, 100)
UnmorphButton.Text = "üö´ UNMORPH (Return to Normal)"
UnmorphButton.TextScaled = true
UnmorphButton.Font = Enum.Font.GothamBold
UnmorphButton.BorderSizePixel = 0
UnmorphButton.AutoButtonColor = false
UnmorphButton.Parent = MainFrame

local umCorner = Instance.new("UICorner")
umCorner.CornerRadius = UDim.new(0, 10)
umCorner.Parent = UnmorphButton

local umStroke = Instance.new("UIStroke")
umStroke.Color = Color3.fromRGB(255, 50, 50)
umStroke.Thickness = 1
umStroke.Parent = UnmorphButton

UnmorphButton.MouseButton1Click:Connect(function()
	ClearMorph()
	FlashScreen(Color3.fromRGB(255, 100, 100), 0.3)
end)

UnmorphButton.MouseEnter:Connect(function()
	TweenService:Create(UnmorphButton, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(120, 0, 0)}):Play()
end)
UnmorphButton.MouseLeave:Connect(function()
	TweenService:Create(UnmorphButton, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(80, 0, 0)}):Play()
end)

-- Create creature cards
for i, creature in ipairs(Creatures) do
	local card = Instance.new("Frame")
	card.Name = creature.Name
	card.Size = UDim2.new(1, 0, 0, 0)
	card.AutomaticSize = Enum.AutomaticSize.Y
	card.BackgroundColor3 = Color3.fromRGB(20, 20, 28)
	card.BorderSizePixel = 0
	card.Parent = CardContainer
	card.ClipsDescendants = true
	
	local cCorner = Instance.new("UICorner")
	cCorner.CornerRadius = UDim.new(0, 12)
	cCorner.Parent = card
	
	local cStroke = Instance.new("UIStroke")
	cStroke.Color = creature.Color
	cStroke.Thickness = 1.5
	cStroke.Transparency = 0.5
	cStroke.Parent = card
	
	local cPadding = Instance.new("UIPadding")
	cPadding.PaddingTop = UDim.new(0, 8)
	cPadding.PaddingBottom = UDim.new(0, 8)
	cPadding.PaddingLeft = UDim.new(0, 10)
	cPadding.PaddingRight = UDim.new(0, 10)
	cPadding.Parent = card
	
	local cLayout = Instance.new("UIListLayout")
	cLayout.Padding = UDim.new(0, 5)
	cLayout.Parent = card
	
	-- Header row
	local headerRow = Instance.new("Frame")
	headerRow.Size = UDim2.new(1, 0, 0, 35)
	headerRow.BackgroundTransparency = 1
	headerRow.LayoutOrder = 1
	headerRow.Parent = card
	
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Size = UDim2.new(0.6, 0, 1, 0)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = creature.Icon .. " " .. creature.Name
	nameLabel.TextColor3 = creature.Color
	nameLabel.TextScaled = true
	nameLabel.Font = Enum.Font.GothamBold
	nameLabel.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel.Parent = headerRow
	
	local morphBtn = Instance.new("TextButton")
	morphBtn.Size = UDim2.new(0.35, 0, 0.9, 0)
	morphBtn.Position = UDim2.new(0.65, 0, 0.05, 0)
	morphBtn.BackgroundColor3 = creature.Color
	morphBtn.TextColor3 = Color3.new(1, 1, 1)
	morphBtn.Text = "‚ö° MORPH"
	morphBtn.TextScaled = true
	morphBtn.Font = Enum.Font.GothamBold
	morphBtn.BorderSizePixel = 0
	morphBtn.AutoButtonColor = false
	morphBtn.Parent = headerRow
	
	local mbCorner = Instance.new("UICorner")
	mbCorner.CornerRadius = UDim.new(0, 8)
	mbCorner.Parent = morphBtn
	
	morphBtn.MouseButton1Click:Connect(function()
		MorphInto(i)
		
		-- Flash effect on button
		TweenService:Create(morphBtn, TweenInfo.new(0.1), {BackgroundColor3 = Color3.new(1, 1, 1)}):Play()
		task.wait(0.1)
		TweenService:Create(morphBtn, TweenInfo.new(0.3), {BackgroundColor3 = creature.Color}):Play()
	end)
	
	morphBtn.MouseEnter:Connect(function()
		TweenService:Create(morphBtn, TweenInfo.new(0.2), {
			BackgroundColor3 = Color3.new(
				math.min(creature.Color.R + 0.2, 1),
				math.min(creature.Color.G + 0.2, 1),
				math.min(creature.Color.B + 0.2, 1)
			)
		}):Play()
		TweenService:Create(cStroke, TweenInfo.new(0.2), {Transparency = 0}):Play()
	end)
	morphBtn.MouseLeave:Connect(function()
		TweenService:Create(morphBtn, TweenInfo.new(0.2), {BackgroundColor3 = creature.Color}):Play()
		TweenService:Create(cStroke, TweenInfo.new(0.2), {Transparency = 0.5}):Play()
	end)
	
	-- Description
	local descLabel = Instance.new("TextLabel")
	descLabel.Size = UDim2.new(1, 0, 0, 25)
	descLabel.BackgroundTransparency = 1
	descLabel.Text = creature.Description
	descLabel.TextColor3 = Color3.fromRGB(160, 160, 170)
	descLabel.TextScaled = true
	descLabel.Font = Enum.Font.Gotham
	descLabel.TextXAlignment = Enum.TextXAlignment.Left
	descLabel.TextWrapped = true
	descLabel.LayoutOrder = 2
	descLabel.Parent = card
	
	-- Stats
	local statsLabel = Instance.new("TextLabel")
	statsLabel.Size = UDim2.new(1, 0, 0, 16)
	statsLabel.BackgroundTransparency = 1
	statsLabel.Text = string.format("Speed: %d | Jump: %d | Scale: %.1fx", creature.WalkSpeed, creature.JumpPower, creature.BodyScale.Height)
	statsLabel.TextColor3 = creature.SecondaryColor
	statsLabel.TextScaled = true
	statsLabel.Font = Enum.Font.Code
	statsLabel.TextXAlignment = Enum.TextXAlignment.Left
	statsLabel.LayoutOrder = 3
	statsLabel.Parent = card
	
	-- Abilities
	for j, ability in ipairs(creature.Abilities) do
		local abilityFrame = Instance.new("Frame")
		abilityFrame.Size = UDim2.new(1, 0, 0, 28)
		abilityFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
		abilityFrame.BorderSizePixel = 0
		abilityFrame.LayoutOrder = 3 + j
		abilityFrame.Parent = card
		
		local abCorner = Instance.new("UICorner")
		abCorner.CornerRadius = UDim.new(0, 6)
		abCorner.Parent = abilityFrame
		
		local keyBadge = Instance.new("TextLabel")
		keyBadge.Size = UDim2.new(0, 28, 0, 22)
		keyBadge.Position = UDim2.new(0, 4, 0.5, -11)
		keyBadge.BackgroundColor3 = creature.AccentColor
		keyBadge.TextColor3 = Color3.new(0, 0, 0)
		keyBadge.Text = ability.Key
		keyBadge.TextScaled = true
		keyBadge.Font = Enum.Font.GothamBold
		keyBadge.Parent = abilityFrame
		
		local kbCorner = Instance.new("UICorner")
		kbCorner.CornerRadius = UDim.new(0, 4)
		kbCorner.Parent = keyBadge
		
		local abName = Instance.new("TextLabel")
		abName.Size = UDim2.new(0.35, 0, 1, 0)
		abName.Position = UDim2.new(0, 38, 0, 0)
		abName.BackgroundTransparency = 1
		abName.Text = ability.Name
		abName.TextColor3 = creature.AccentColor
		abName.TextScaled = true
		abName.Font = Enum.Font.GothamBold
		abName.TextXAlignment = Enum.TextXAlignment.Left
		abName.Parent = abilityFrame
		
		local abDesc = Instance.new("TextLabel")
		abDesc.Size = UDim2.new(0.5, -5, 1, 0)
		abDesc.Position = UDim2.new(0.5, 0, 0, 0)
		abDesc.BackgroundTransparency = 1
		abDesc.Text = string.format("DMG:%d CD:%.1fs", ability.Damage, ability.Cooldown)
		abDesc.TextColor3 = Color3.fromRGB(130, 130, 140)
		abDesc.TextScaled = true
		abDesc.Font = Enum.Font.Code
		abDesc.TextXAlignment = Enum.TextXAlignment.Right
		abDesc.Parent = abilityFrame
	end
end

-- Ability HUD (shows when morphed)
local AbilityHUD = Instance.new("Frame")
AbilityHUD.Name = "AbilityHUD"
AbilityHUD.Size = UDim2.new(0, 400, 0, 70)
AbilityHUD.Position = UDim2.new(0.5, -200, 1, -90)
AbilityHUD.BackgroundColor3 = Color3.fromRGB(12, 12, 18)
AbilityHUD.BackgroundTransparency = 0.3
AbilityHUD.BorderSizePixel = 0
AbilityHUD.Visible = false
AbilityHUD.Parent = ScreenGui

local hudCorner = Instance.new("UICorner")
hudCorner.CornerRadius = UDim.new(0, 12)
hudCorner.Parent = AbilityHUD

local hudStroke = Instance.new("UIStroke")
hudStroke.Thickness = 1.5
hudStroke.Transparency = 0.5
hudStroke.Parent = AbilityHUD

local hudLayout = Instance.new("UIListLayout")
hudLayout.FillDirection = Enum.FillDirection.Horizontal
hudLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
hudLayout.VerticalAlignment = Enum.VerticalAlignment.Center
hudLayout.Padding = UDim.new(0, 10)
hudLayout.Parent = AbilityHUD

-- Morph name label
local MorphNameLabel = Instance.new("TextLabel")
MorphNameLabel.Name = "MorphName"
MorphNameLabel.Size = UDim2.new(0, 200, 0, 25)
MorphNameLabel.Position = UDim2.new(0.5, -100, 1, -115)
MorphNameLabel.BackgroundTransparency = 1
MorphNameLabel.TextColor3 = Color3.new(1, 1, 1)
MorphNameLabel.TextScaled = true
MorphNameLabel.Font = Enum.Font.GothamBold
MorphNameLabel.Text = ""
MorphNameLabel.Visible = false
MorphNameLabel.Parent = ScreenGui

local AbilitySlots = {}

for k = 1, 4 do
	local slot = Instance.new("Frame")
	slot.Name = "Slot" .. k
	slot.Size = UDim2.new(0, 85, 0, 55)
	slot.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
	slot.BorderSizePixel = 0
	slot.Parent = AbilityHUD
	
	local sCorner = Instance.new("UICorner")
	sCorner.CornerRadius = UDim.new(0, 8)
	sCorner.Parent = slot
	
	local sStroke = Instance.new("UIStroke")
	sStroke.Thickness = 1.5
	sStroke.Parent = slot
	
	local keyLabel = Instance.new("TextLabel")
	keyLabel.Name = "Key"
	keyLabel.Size = UDim2.new(0, 22, 0, 18)
	keyLabel.Position = UDim2.new(0, 4, 0, 3)
	keyLabel.BackgroundColor3 = Color3.fromRGB(200, 200, 200)
	keyLabel.TextColor3 = Color3.new(0, 0, 0)
	keyLabel.Text = ({"Q", "E", "R", "T"})[k]
	keyLabel.TextScaled = true
	keyLabel.Font = Enum.Font.GothamBold
	keyLabel.Parent = slot
	
	local klCorner = Instance.new("UICorner")
	klCorner.CornerRadius = UDim.new(0, 3)
	klCorner.Parent = keyLabel
	
	local nameLabel2 = Instance.new("TextLabel")
	nameLabel2.Name = "AbilityName"
	nameLabel2.Size = UDim2.new(1, -30, 0, 16)
	nameLabel2.Position = UDim2.new(0, 28, 0, 3)
	nameLabel2.BackgroundTransparency = 1
	nameLabel2.TextColor3 = Color3.new(1, 1, 1)
	nameLabel2.Text = ""
	nameLabel2.TextScaled = true
	nameLabel2.Font = Enum.Font.GothamBold
	nameLabel2.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel2.Parent = slot
	
	local cdBar = Instance.new("Frame")
	cdBar.Name = "CooldownBar"
	cdBar.Size = UDim2.new(1, -8, 0, 6)
	cdBar.Position = UDim2.new(0, 4, 1, -10)
	cdBar.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
	cdBar.BorderSizePixel = 0
	cdBar.Parent = slot
	
	local cbCorner = Instance.new("UICorner")
	cbCorner.CornerRadius = UDim.new(0, 3)
	cbCorner.Parent = cdBar
	
	local cdFill = Instance.new("Frame")
	cdFill.Name = "Fill"
	cdFill.Size = UDim2.new(1, 0, 1, 0)
	cdFill.BackgroundColor3 = Color3.fromRGB(0, 255, 100)
	cdFill.BorderSizePixel = 0
	cdFill.Parent = cdBar
	
	local cfCorner = Instance.new("UICorner")
	cfCorner.CornerRadius = UDim.new(0, 3)
	cfCorner.Parent = cdFill
	
	local cdText = Instance.new("TextLabel")
	cdText.Name = "CooldownText"
	cdText.Size = UDim2.new(1, 0, 0, 14)
	cdText.Position = UDim2.new(0, 0, 0, 22)
	cdText.BackgroundTransparency = 1
	cdText.TextColor3 = Color3.fromRGB(150, 150, 160)
	cdText.Text = "READY"
	cdText.TextScaled = true
	cdText.Font = Enum.Font.Code
	cdText.Parent = slot
	
	AbilitySlots[k] = slot
end

-- Update HUD
local function UpdateHUD()
	if not CurrentMorph then
		AbilityHUD.Visible = false
		MorphNameLabel.Visible = false
		return
	end
	
	local creature = Creatures[CurrentMorph]
	AbilityHUD.Visible = true
	MorphNameLabel.Visible = true
	MorphNameLabel.Text = creature.Icon .. " " .. creature.Name
	MorphNameLabel.TextColor3 = creature.Color
	hudStroke.Color = creature.Color
	
	for k = 1, 4 do
		local slot = AbilitySlots[k]
		local ability = creature.Abilities[k]
		
		slot:FindFirstChild("AbilityName").Text = ability.Name
		slot:FindFirstChild("AbilityName").TextColor3 = creature.AccentColor
		slot:FindFirstChild("Key").BackgroundColor3 = creature.AccentColor
		
		local fill = slot:FindFirstChild("CooldownBar"):FindFirstChild("Fill")
		local cdText = slot:FindFirstChild("CooldownText")
		
		local now = tick()
		local ready = Cooldowns[ability.Key] or 0
		
		if now >= ready then
			fill.Size = UDim2.new(1, 0, 1, 0)
			fill.BackgroundColor3 = creature.AccentColor
			cdText.Text = "READY"
			cdText.TextColor3 = Color3.fromRGB(0, 255, 100)
		else
			local remaining = ready - now
			local ratio = 1 - (remaining / ability.Cooldown)
			fill.Size = UDim2.new(math.clamp(ratio, 0, 1), 0, 1, 0)
			fill.BackgroundColor3 = Color3.fromRGB(255, 100, 0)
			cdText.Text = string.format("%.1fs", remaining)
			cdText.TextColor3 = Color3.fromRGB(255, 150, 50)
		end
	end
end

-- HUD update loop
RunService.Heartbeat:Connect(function()
	UpdateHUD()
end)

--------------------------------------------------------------------
-- INPUT HANDLING
--------------------------------------------------------------------

-- Toggle menu
ToggleButton.MouseButton1Click:Connect(function()
	IsMenuOpen = not IsMenuOpen
	MainFrame.Visible = IsMenuOpen
	
	if IsMenuOpen then
		MainFrame.Size = UDim2.new(0, 0, 0, 0)
		MainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
		TweenService:Create(MainFrame, TweenInfo.new(0.4, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
			Size = UDim2.new(0, 550, 0, 520),
			Position = UDim2.new(0.5, -275, 0.5, -260),
		}):Play()
	else
		TweenService:Create(MainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
			Size = UDim2.new(0, 0, 0, 0),
			Position = UDim2.new(0.5, 0, 0.5, 0),
		}):Play()
		task.delay(0.3, function()
			MainFrame.Visible = false
		end)
	end
end)

-- Ability keys
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	
	-- M to toggle menu
	if input.KeyCode == Enum.KeyCode.M then
		ToggleButton.MouseButton1Click:Fire()
		return
	end
	
	if not CurrentMorph then return end
	
	local keyMap = {
		[Enum.KeyCode.Q] = 1,
		[Enum.KeyCode.E] = 2,
		[Enum.KeyCode.R] = 3,
		[Enum.KeyCode.T] = 4,
	}
	
	local abilityIndex = keyMap[input.KeyCode]
	if abilityIndex then
		UseAbility(abilityIndex)
	end
end)

-- Make frame draggable
local dragging = false
local dragStart = nil
local startPos = nil

TitleBar.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		dragging = true
		dragStart = input.Position
		startPos = MainFrame.Position
	end
end)

TitleBar.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		dragging = false
	end
end)

UserInputService.InputChanged:Connect(function(input)
	if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
		local delta = input.Position - dragStart
		MainFrame.Position = UDim2.new(
			startPos.X.Scale,
			startPos.X.Offset + delta.X,
			startPos.Y.Scale,
			startPos.Y.Offset + delta.Y
		)
	end
end)

--------------------------------------------------------------------
-- IDLE MORPH ANIMATIONS
--------------------------------------------------------------------
RunService.Heartbeat:Connect(function(dt)
	if not CurrentMorph then return end
	
	local char = GetCharacter()
	local hrp = GetHRP()
	if not char or not hrp then return end
	
	local creature = Creatures[CurrentMorph]
	
	-- Ambient particles
	if math.random() < 0.05 then
		local offset = Vector3.new(math.random(-3, 3), math.random(-1, 3), math.random(-3, 3))
		local pos = hrp.Position + offset
		
		local spark = Instance.new("Part")
		spark.Shape = Enum.PartType.Ball
		spark.Size = Vector3.new(0.2, 0.2, 0.2)
		spark.Position = pos
		spark.Anchored = true
		spark.CanCollide = false
		spark.Material = Enum.Material.Neon
		spark.Color = creature.AccentColor
		spark.Parent = workspace
		
		TweenService:Create(spark, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			Size = Vector3.new(0, 0, 0),
			Transparency = 1,
			Position = pos + Vector3.new(0, 2, 0),
		}):Play()
		
		Debris:AddItem(spark, 0.5)
	end
	
	-- Footstep effects when moving
	local humanoid = GetHumanoid()
	if humanoid and humanoid.MoveDirection.Magnitude > 0 then
		if math.random() < 0.1 then
			local footPos = hrp.Position - Vector3.new(0, 3, 0) + Vector3.new(math.random(-1, 1), 0, math.random(-1, 1))
			
			local footprint = Instance.new("Part")
			footprint.Shape = Enum.PartType.Cylinder
			footprint.Size = Vector3.new(0.1, 1.5, 1.5)
			footprint.CFrame = CFrame.new(footPos) * CFrame.Angles(0, 0, math.rad(90))
			footprint.Anchored = true
			footprint.CanCollide = false
			footprint.Material = Enum.Material.Neon
			footprint.Color = creature.Color
			footprint.Transparency = 0.5
			footprint.Parent = workspace
			
			TweenService:Create(footprint, TweenInfo.new(1), {
				Transparency = 1,
				Size = Vector3.new(0.1, 3, 3),
			}):Play()
			
			Debris:AddItem(footprint, 1)
		end
	end
end)

--------------------------------------------------------------------
-- RESPAWN HANDLING
--------------------------------------------------------------------
Player.CharacterAdded:Connect(function(char)
	task.wait(1) -- Wait for character to load
	
	if CurrentMorph then
		local savedMorph = CurrentMorph
		CurrentMorph = nil
		ActiveEffects = {}
		MorphParts = {}
		MorphInto(savedMorph)
	end
end)

--------------------------------------------------------------------
-- INITIALIZATION
--------------------------------------------------------------------
print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
print("üëÅÔ∏è SVG BOB'S UNHINGED MORPH MENU LOADED")
print("Press M or click the SVG button to open")
print("5 Creatures | 20 Unique Abilities | Pure Chaos")
print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
