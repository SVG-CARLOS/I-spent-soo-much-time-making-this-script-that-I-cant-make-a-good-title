--[[
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              ğŸ¤¡ CLOWN MOVESET OVERRIDE V2 ğŸ¤¡                    â•‘
â•‘          THE STRONGEST BATTLEGROUNDS - Full Rework               â•‘
â•‘                                                                  â•‘
â•‘  â€¢ Procedural CFrame Animations (NO animation IDs needed)        â•‘
â•‘  â€¢ Tool-based ability system that replaces existing ones         â•‘
â•‘  â€¢ Custom UI overlay on the existing moveset bar                 â•‘
â•‘  â€¢ Full VFX, SFX, Camera Work                                   â•‘
â•‘  â€¢ Ultimate Awakening with cinematic sequence                    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")
local SoundService = game:GetService("SoundService")

local Player = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local Mouse = Player:GetMouse()

local Character, Humanoid, HumanoidRootPart, Torso, RightArm, LeftArm, RightLeg, LeftLeg, Head
local RightShoulder, LeftShoulder, RightHip, LeftHip, Neck, RootJoint

-- Store original C0s for resetting
local OriginalC0 = {}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- WAIT FOR CHARACTER & CACHE EVERYTHING
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local function CacheCharacter(char)
	Character = char
	Humanoid = char:WaitForChild("Humanoid")
	HumanoidRootPart = char:WaitForChild("HumanoidRootPart")
	
	-- R15 vs R6 detection
	local isR6 = char:FindFirstChild("Torso") ~= nil
	
	if isR6 then
		Torso = char:WaitForChild("Torso")
		Head = char:WaitForChild("Head")
		RightArm = char:WaitForChild("Right Arm")
		LeftArm = char:WaitForChild("Left Arm")
		RightLeg = char:WaitForChild("Right Leg")
		LeftLeg = char:WaitForChild("Left Leg")
		
		RightShoulder = Torso:WaitForChild("Right Shoulder")
		LeftShoulder = Torso:WaitForChild("Left Shoulder")
		RightHip = Torso:WaitForChild("Right Hip")
		LeftHip = Torso:WaitForChild("Left Hip")
		Neck = Torso:WaitForChild("Neck")
		RootJoint = HumanoidRootPart:WaitForChild("RootJoint")
		
		-- Save originals
		OriginalC0.RightShoulder = RightShoulder.C0
		OriginalC0.LeftShoulder = LeftShoulder.C0
		OriginalC0.RightHip = RightHip.C0
		OriginalC0.LeftHip = LeftHip.C0
		OriginalC0.Neck = Neck.C0
		OriginalC0.RootJoint = RootJoint.C0
	else
		-- R15
		Torso = char:WaitForChild("UpperTorso", 3) or char:WaitForChild("Torso", 3)
		Head = char:WaitForChild("Head")
		
		-- For R15 we find Motor6Ds differently
		local function findMotor(parent, name)
			for _, v in pairs(parent:GetDescendants()) do
				if v:IsA("Motor6D") and v.Name == name then
					return v
				end
			end
			return nil
		end
		
		-- Try to find R15 joints
		RightShoulder = findMotor(char, "RightShoulder")
		LeftShoulder = findMotor(char, "LeftShoulder")
		RightHip = findMotor(char, "RightHip")
		LeftHip = findMotor(char, "LeftHip")
		Neck = findMotor(char, "Neck")
		RootJoint = findMotor(char, "Root") or findMotor(char, "RootJoint")
		
		if RightShoulder then OriginalC0.RightShoulder = RightShoulder.C0 end
		if LeftShoulder then OriginalC0.LeftShoulder = LeftShoulder.C0 end
		if RightHip then OriginalC0.RightHip = RightHip.C0 end
		if LeftHip then OriginalC0.LeftHip = LeftHip.C0 end
		if Neck then OriginalC0.Neck = Neck.C0 end
		if RootJoint then OriginalC0.RootJoint = RootJoint.C0 end
	end
end

Character = Player.Character or Player.CharacterAdded:Wait()
CacheCharacter(Character)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- STATE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local State = {
	M1Count = 0,
	M1LastTime = 0,
	M1Window = 0.9,
	
	Attacking = false,
	Blocking = false,
	UsingSkill = false,
	Dashing = false,
	UltActive = false,
	Awakened = false,
	Animating = false,
	
	UltMeter = 0,
	UltMax = 100,
	
	Cooldowns = {
		Skill1 = 0,
		Skill2 = 0,
		Skill3 = 0,
		Skill4 = 0,
		Ultimate = 0,
	},
	
	CooldownDurations = {
		Skill1 = 5,
		Skill2 = 7,
		Skill3 = 9,
		Skill4 = 12,
		Ultimate = 45,
	},
	
	CurrentTweens = {},
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PROCEDURAL CFRAME ANIMATION ENGINE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local Anim = {}

function Anim.StopAll()
	for _, tween in pairs(State.CurrentTweens) do
		if tween and tween.Cancel then
			pcall(function() tween:Cancel() end)
		end
	end
	State.CurrentTweens = {}
end

function Anim.ResetPose(speed)
	speed = speed or 0.2
	Anim.StopAll()
	
	local joints = {
		{RightShoulder, "RightShoulder"},
		{LeftShoulder, "LeftShoulder"},
		{RightHip, "RightHip"},
		{LeftHip, "LeftHip"},
		{Neck, "Neck"},
		{RootJoint, "RootJoint"},
	}
	
	for _, data in pairs(joints) do
		local joint = data[1]
		local name = data[2]
		if joint and OriginalC0[name] then
			local tw = TweenService:Create(joint, TweenInfo.new(speed, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				C0 = OriginalC0[name]
			})
			tw:Play()
			table.insert(State.CurrentTweens, tw)
		end
	end
end

function Anim.TweenJoint(joint, goalC0, duration, style, direction)
	if not joint then return nil end
	style = style or Enum.EasingStyle.Quad
	direction = direction or Enum.EasingDirection.Out
	duration = duration or 0.2
	
	local tw = TweenService:Create(joint, TweenInfo.new(duration, style, direction), {
		C0 = goalC0
	})
	tw:Play()
	table.insert(State.CurrentTweens, tw)
	return tw
end

function Anim.TweenJointLoop(joint, goalC0, duration, style, direction)
	if not joint then return nil end
	style = style or Enum.EasingStyle.Sine
	direction = direction or Enum.EasingDirection.InOut
	
	local tw = TweenService:Create(joint, TweenInfo.new(duration, style, direction, -1, true), {
		C0 = goalC0
	})
	tw:Play()
	table.insert(State.CurrentTweens, tw)
	return tw
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CLOWN IDLE ANIMATION (Bouncy & Playful)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local idleConnection = nil

function Anim.StartClownIdle()
	if State.Animating then return end
	
	-- Stop any existing idle
	Anim.StopClownIdle()
	
	if not RootJoint then return end
	
	local t = 0
	idleConnection = RunService.Heartbeat:Connect(function(dt)
		if State.Animating or State.Attacking or State.UsingSkill then return end
		t = t + dt
		
		-- Bouncy body sway
		local bounce = math.sin(t * 3) * 0.05
		local sway = math.sin(t * 1.5) * 0.08
		local headBob = math.sin(t * 2) * 0.03
		
		if RootJoint and OriginalC0.RootJoint then
			RootJoint.C0 = OriginalC0.RootJoint 
				* CFrame.new(0, bounce, 0) 
				* CFrame.Angles(0, sway, 0)
		end
		
		if Neck and OriginalC0.Neck then
			Neck.C0 = OriginalC0.Neck 
				* CFrame.Angles(headBob, math.sin(t * 1.2) * 0.05, math.sin(t * 0.8) * 0.03)
		end
		
		-- Arms slightly out and swaying like a clown
		if RightShoulder and OriginalC0.RightShoulder then
			RightShoulder.C0 = OriginalC0.RightShoulder 
				* CFrame.Angles(
					math.sin(t * 2) * 0.1, 
					0, 
					math.rad(15) + math.sin(t * 1.5) * 0.08
				)
		end
		
		if LeftShoulder and OriginalC0.LeftShoulder then
			LeftShoulder.C0 = OriginalC0.LeftShoulder 
				* CFrame.Angles(
					math.sin(t * 2 + 1) * 0.1, 
					0, 
					math.rad(-15) + math.sin(t * 1.5 + 1) * -0.08
				)
		end
		
		-- Slight leg bounce
		if RightHip and OriginalC0.RightHip then
			RightHip.C0 = OriginalC0.RightHip 
				* CFrame.Angles(math.sin(t * 3) * 0.02, 0, 0)
		end
		
		if LeftHip and OriginalC0.LeftHip then
			LeftHip.C0 = OriginalC0.LeftHip 
				* CFrame.Angles(math.sin(t * 3 + math.pi) * 0.02, 0, 0)
		end
	end)
end

function Anim.StopClownIdle()
	if idleConnection then
		idleConnection:Disconnect()
		idleConnection = nil
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- M1 COMBO ANIMATIONS (5 Hits - Pure CFrame)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Hit 1: Right Slap
function Anim.M1_Hit1()
	State.Animating = true
	Anim.StopClownIdle()
	
	-- Wind up right arm back
	if RightShoulder and OriginalC0.RightShoulder then
		Anim.TweenJoint(RightShoulder,
			OriginalC0.RightShoulder * CFrame.Angles(math.rad(-30), math.rad(40), math.rad(20)),
			0.06, Enum.EasingStyle.Back, Enum.EasingDirection.Out
		)
	end
	if RootJoint and OriginalC0.RootJoint then
		Anim.TweenJoint(RootJoint,
			OriginalC0.RootJoint * CFrame.Angles(0, math.rad(25), 0),
			0.06
		)
	end
	
	wait(0.06)
	
	-- SLAP forward
	if RightShoulder and OriginalC0.RightShoulder then
		Anim.TweenJoint(RightShoulder,
			OriginalC0.RightShoulder * CFrame.Angles(math.rad(20), math.rad(-60), math.rad(30)),
			0.05, Enum.EasingStyle.Quad, Enum.EasingDirection.Out
		)
	end
	if RootJoint and OriginalC0.RootJoint then
		Anim.TweenJoint(RootJoint,
			OriginalC0.RootJoint * CFrame.Angles(math.rad(5), math.rad(-30), 0),
			0.06
		)
	end
	if Neck and OriginalC0.Neck then
		Anim.TweenJoint(Neck,
			OriginalC0.Neck * CFrame.Angles(math.rad(-5), math.rad(-20), 0),
			0.05
		)
	end
	
	wait(0.15)
	State.Animating = false
end

-- Hit 2: Left Backhand
function Anim.M1_Hit2()
	State.Animating = true
	Anim.StopClownIdle()
	
	-- Wind up left arm
	if LeftShoulder and OriginalC0.LeftShoulder then
		Anim.TweenJoint(LeftShoulder,
			OriginalC0.LeftShoulder * CFrame.Angles(math.rad(-20), math.rad(-50), math.rad(-25)),
			0.06, Enum.EasingStyle.Back
		)
	end
	if RootJoint and OriginalC0.RootJoint then
		Anim.TweenJoint(RootJoint,
			OriginalC0.RootJoint * CFrame.Angles(0, math.rad(-30), 0),
			0.06
		)
	end
	
	wait(0.06)
	
	-- Backhand swing
	if LeftShoulder and OriginalC0.LeftShoulder then
		Anim.TweenJoint(LeftShoulder,
			OriginalC0.LeftShoulder * CFrame.Angles(math.rad(30), math.rad(70), math.rad(-20)),
			0.05
		)
	end
	if RootJoint and OriginalC0.RootJoint then
		Anim.TweenJoint(RootJoint,
			OriginalC0.RootJoint * CFrame.Angles(math.rad(5), math.rad(35), 0),
			0.06
		)
	end
	if Neck and OriginalC0.Neck then
		Anim.TweenJoint(Neck,
			OriginalC0.Neck * CFrame.Angles(math.rad(-5), math.rad(25), 0),
			0.05
		)
	end
	
	wait(0.15)
	State.Animating = false
end

-- Hit 3: Overhead Bonk
function Anim.M1_Hit3()
	State.Animating = true
	Anim.StopClownIdle()
	
	-- Both arms up
	if RightShoulder and OriginalC0.RightShoulder then
		Anim.TweenJoint(RightShoulder,
			OriginalC0.RightShoulder * CFrame.Angles(math.rad(-170), 0, math.rad(15)),
			0.08, Enum.EasingStyle.Back
		)
	end
	if LeftShoulder and OriginalC0.LeftShoulder then
		Anim.TweenJoint(LeftShoulder,
			OriginalC0.LeftShoulder * CFrame.Angles(math.rad(-170), 0, math.rad(-15)),
			0.08, Enum.EasingStyle.Back
		)
	end
	if RootJoint and OriginalC0.RootJoint then
		Anim.TweenJoint(RootJoint,
			OriginalC0.RootJoint * CFrame.new(0, 0.2, 0) * CFrame.Angles(math.rad(-10), 0, 0),
			0.08
		)
	end
	
	wait(0.1)
	
	-- SLAM down
	if RightShoulder and OriginalC0.RightShoulder then
		Anim.TweenJoint(RightShoulder,
			OriginalC0.RightShoulder * CFrame.Angles(math.rad(40), 0, math.rad(10)),
			0.06, Enum.EasingStyle.Quad
		)
	end
	if LeftShoulder and OriginalC0.LeftShoulder then
		Anim.TweenJoint(LeftShoulder,
			OriginalC0.LeftShoulder * CFrame.Angles(math.rad(40), 0, math.rad(-10)),
			0.06, Enum.EasingStyle.Quad
		)
	end
	if RootJoint and OriginalC0.RootJoint then
		Anim.TweenJoint(RootJoint,
			OriginalC0.RootJoint * CFrame.new(0, -0.3, 0) * CFrame.Angles(math.rad(25), 0, 0),
			0.06
		)
	end
	if Neck and OriginalC0.Neck then
		Anim.TweenJoint(Neck,
			OriginalC0.Neck * CFrame.Angles(math.rad(15), 0, 0),
			0.06
		)
	end
	
	wait(0.18)
	State.Animating = false
end

-- Hit 4: Spinning Elbow
function Anim.M1_Hit4()
	State.Animating = true
	Anim.StopClownIdle()
	
	-- Spin windup
	if RootJoint and OriginalC0.RootJoint then
		Anim.TweenJoint(RootJoint,
			OriginalC0.RootJoint * CFrame.Angles(0, math.rad(-60), 0),
			0.06
		)
	end
	if RightShoulder and OriginalC0.RightShoulder then
		Anim.TweenJoint(RightShoulder,
			OriginalC0.RightShoulder * CFrame.Angles(math.rad(-90), math.rad(30), math.rad(40)),
			0.06
		)
	end
	
	wait(0.06)
	
	-- Spin through with elbow
	if RootJoint and OriginalC0.RootJoint then
		Anim.TweenJoint(RootJoint,
			OriginalC0.RootJoint * CFrame.Angles(math.rad(8), math.rad(120), 0),
			0.08, Enum.EasingStyle.Quad
		)
	end
	if RightShoulder and OriginalC0.RightShoulder then
		Anim.TweenJoint(RightShoulder,
			OriginalC0.RightShoulder * CFrame.Angles(math.rad(-80), math.rad(-50), math.rad(60)),
			0.07
		)
	end
	if LeftShoulder and OriginalC0.LeftShoulder then
		Anim.TweenJoint(LeftShoulder,
			OriginalC0.LeftShoulder * CFrame.Angles(math.rad(20), math.rad(20), math.rad(-30)),
			0.07
		)
	end
	
	wait(0.18)
	State.Animating = false
end

-- Hit 5: BIG Uppercut (Launcher)
function Anim.M1_Hit5()
	State.Animating = true
	Anim.StopClownIdle()
	
	-- Crouch down wind up
	if RootJoint and OriginalC0.RootJoint then
		Anim.TweenJoint(RootJoint,
			OriginalC0.RootJoint * CFrame.new(0, -0.5, 0) * CFrame.Angles(math.rad(20), math.rad(-15), 0),
			0.08
		)
	end
	if RightShoulder and OriginalC0.RightShoulder then
		Anim.TweenJoint(RightShoulder,
			OriginalC0.RightShoulder * CFrame.Angles(math.rad(30), math.rad(30), math.rad(10)),
			0.08
		)
	end
	if LeftShoulder and OriginalC0.LeftShoulder then
		Anim.TweenJoint(LeftShoulder,
			OriginalC0.LeftShoulder * CFrame.Angles(math.rad(20), math.rad(-10), math.rad(-20)),
			0.08
		)
	end
	if RightHip and OriginalC0.RightHip then
		Anim.TweenJoint(RightHip,
			OriginalC0.RightHip * CFrame.Angles(math.rad(-20), 0, 0),
			0.08
		)
	end
	if LeftHip and OriginalC0.LeftHip then
		Anim.TweenJoint(LeftHip,
			OriginalC0.LeftHip * CFrame.Angles(math.rad(-25), 0, 0),
			0.08
		)
	end
	
	wait(0.1)
	
	-- EXPLOSIVE UPPERCUT
	if RootJoint and OriginalC0.RootJoint then
		Anim.TweenJoint(RootJoint,
			OriginalC0.RootJoint * CFrame.new(0, 0.4, 0) * CFrame.Angles(math.rad(-15), math.rad(20), 0),
			0.06, Enum.EasingStyle.Back, Enum.EasingDirection.Out
		)
	end
	if RightShoulder and OriginalC0.RightShoulder then
		Anim.TweenJoint(RightShoulder,
			OriginalC0.RightShoulder * CFrame.Angles(math.rad(-160), math.rad(-20), math.rad(25)),
			0.06, Enum.EasingStyle.Back, Enum.EasingDirection.Out
		)
	end
	if LeftShoulder and OriginalC0.LeftShoulder then
		Anim.TweenJoint(LeftShoulder,
			OriginalC0.LeftShoulder * CFrame.Angles(math.rad(30), 0, math.rad(-40)),
			0.06
		)
	end
	if Neck and OriginalC0.Neck then
		Anim.TweenJoint(Neck,
			OriginalC0.Neck * CFrame.Angles(math.rad(-20), math.rad(10), 0),
			0.06
		)
	end
	if RightHip and OriginalC0.RightHip then
		Anim.TweenJoint(RightHip,
			OriginalC0.RightHip * CFrame.Angles(math.rad(10), 0, 0),
			0.06
		)
	end
	if LeftHip and OriginalC0.LeftHip then
		Anim.TweenJoint(LeftHip,
			OriginalC0.LeftHip * CFrame.Angles(math.rad(-10), 0, math.rad(-5)),
			0.06
		)
	end
	
	wait(0.25)
	State.Animating = false
end

-- Skill Animations
function Anim.PieWindup()
	State.Animating = true
	Anim.StopClownIdle()
	
	-- Reach behind back (pulling pie out)
	if RightShoulder and OriginalC0.RightShoulder then
		Anim.TweenJoint(RightShoulder,
			OriginalC0.RightShoulder * CFrame.Angles(math.rad(30), math.rad(60), math.rad(-20)),
			0.12, Enum.EasingStyle.Back
		)
	end
	if RootJoint and OriginalC0.RootJoint then
		Anim.TweenJoint(RootJoint,
			OriginalC0.RootJoint * CFrame.Angles(0, math.rad(30), 0),
			0.12
		)
	end
	if LeftShoulder and OriginalC0.LeftShoulder then
		Anim.TweenJoint(LeftShoulder,
			OriginalC0.LeftShoulder * CFrame.Angles(math.rad(15), 0, math.rad(-15)),
			0.12
		)
	end
end

function Anim.PieThrow()
	-- Forward throw
	if RightShoulder and OriginalC0.RightShoulder then
		Anim.TweenJoint(RightShoulder,
			OriginalC0.RightShoulder * CFrame.Angles(math.rad(-90), math.rad(-30), math.rad(10)),
			0.06, Enum.EasingStyle.Quad
		)
	end
	if RootJoint and OriginalC0.RootJoint then
		Anim.TweenJoint(RootJoint,
			OriginalC0.RootJoint * CFrame.Angles(math.rad(10), math.rad(-40), 0),
			0.06
		)
	end
	if LeftShoulder and OriginalC0.LeftShoulder then
		Anim.TweenJoint(LeftShoulder,
			OriginalC0.LeftShoulder * CFrame.Angles(math.rad(30), math.rad(10), math.rad(-30)),
			0.06
		)
	end
end

function Anim.BalloonTwist()
	State.Animating = true
	Anim.StopClownIdle()
	
	-- Both hands together twisting
	if RightShoulder and OriginalC0.RightShoulder then
		Anim.TweenJoint(RightShoulder,
			OriginalC0.RightShoulder * CFrame.Angles(math.rad(-60), math.rad(-40), math.rad(10)),
			0.1
		)
	end
	if LeftShoulder and OriginalC0.LeftShoulder then
		Anim.TweenJoint(LeftShoulder,
			OriginalC0.LeftShoulder * CFrame.Angles(math.rad(-60), math.rad(40), math.rad(-10)),
			0.1
		)
	end
	if RootJoint and OriginalC0.RootJoint then
		Anim.TweenJoint(RootJoint,
			OriginalC0.RootJoint * CFrame.Angles(math.rad(-5), 0, 0),
			0.1
		)
	end
end

function Anim.BalloonLaunch()
	-- Dramatic push forward
	if RightShoulder and OriginalC0.RightShoulder then
		Anim.TweenJoint(RightShoulder,
			OriginalC0.RightShoulder * CFrame.Angles(math.rad(-100), math.rad(-10), math.rad(30)),
			0.06, Enum.EasingStyle.Back
		)
	end
	if LeftShoulder and OriginalC0.LeftShoulder then
		Anim.TweenJoint(LeftShoulder,
			OriginalC0.LeftShoulder * CFrame.Angles(math.rad(-100), math.rad(10), math.rad(-30)),
			0.06, Enum.EasingStyle.Back
		)
	end
	if RootJoint and OriginalC0.RootJoint then
		Anim.TweenJoint(RootJoint,
			OriginalC0.RootJoint * CFrame.Angles(math.rad(15), 0, 0),
			0.06
		)
	end
end

function Anim.HonkInhale()
	State.Animating = true
	Anim.StopClownIdle()
	
	-- Lean back, puff up
	if RootJoint and OriginalC0.RootJoint then
		Anim.TweenJoint(RootJoint,
			OriginalC0.RootJoint * CFrame.new(0, 0.2, 0) * CFrame.Angles(math.rad(-20), 0, 0),
			0.15
		)
	end
	if RightShoulder and OriginalC0.RightShoulder then
		Anim.TweenJoint(RightShoulder,
			OriginalC0.RightShoulder * CFrame.Angles(math.rad(-30), 0, math.rad(50)),
			0.15
		)
	end
	if LeftShoulder and OriginalC0.LeftShoulder then
		Anim.TweenJoint(LeftShoulder,
			OriginalC0.LeftShoulder * CFrame.Angles(math.rad(-30), 0, math.rad(-50)),
			0.15
		)
	end
	if Neck and OriginalC0.Neck then
		Anim.TweenJoint(Neck,
			OriginalC0.Neck * CFrame.Angles(math.rad(-15), 0, 0),
			0.15
		)
	end
end

function Anim.HonkRelease()
	-- Massive forward push HONK
	if RootJoint and OriginalC0.RootJoint then
		Anim.TweenJoint(RootJoint,
			OriginalC0.RootJoint * CFrame.new(0, -0.3, 0) * CFrame.Angles(math.rad(30), 0, 0),
			0.05, Enum.EasingStyle.Back
		)
	end
	if RightShoulder and OriginalC0.RightShoulder then
		Anim.TweenJoint(RightShoulder,
			OriginalC0.RightShoulder * CFrame.Angles(math.rad(10), 0, math.rad(80)),
			0.05, Enum.EasingStyle.Back
		)
	end
	if LeftShoulder and OriginalC0.LeftShoulder then
		Anim.TweenJoint(LeftShoulder,
			OriginalC0.LeftShoulder * CFrame.Angles(math.rad(10), 0, math.rad(-80)),
			0.05, Enum.EasingStyle.Back
		)
	end
	if Neck and OriginalC0.Neck then
		Anim.TweenJoint(Neck,
			OriginalC0.Neck * CFrame.Angles(math.rad(20), 0, 0),
			0.05
		)
	end
end

function Anim.GrabLunge()
	State.Animating = true
	Anim.StopClownIdle()
	
	-- Reaching grab
	if RightShoulder and OriginalC0.RightShoulder then
		Anim.TweenJoint(RightShoulder,
			OriginalC0.RightShoulder * CFrame.Angles(math.rad(-90), math.rad(-20), math.rad(10)),
			0.08
		)
	end
	if LeftShoulder and OriginalC0.LeftShoulder then
		Anim.TweenJoint(LeftShoulder,
			OriginalC0.LeftShoulder * CFrame.Angles(math.rad(-90), math.rad(20), math.rad(-10)),
			0.08
		)
	end
	if RootJoint and OriginalC0.RootJoint then
		Anim.TweenJoint(RootJoint,
			OriginalC0.RootJoint * CFrame.Angles(math.rad(20), 0, 0),
			0.08
		)
	end
end

function Anim.JuggleToss(side)
	-- Alternating tosses
	local angle = side == "right" and math.rad(30) or math.rad(-30)
	
	if RightShoulder and OriginalC0.RightShoulder then
		Anim.TweenJoint(RightShoulder,
			OriginalC0.RightShoulder * CFrame.Angles(
				math.rad(-140) + (side == "right" and math.rad(20) or 0),
				angle,
				math.rad(15)
			),
			0.08, Enum.EasingStyle.Back
		)
	end
	if LeftShoulder and OriginalC0.LeftShoulder then
		Anim.TweenJoint(LeftShoulder,
			OriginalC0.LeftShoulder * CFrame.Angles(
				math.rad(-140) + (side == "left" and math.rad(20) or 0),
				-angle,
				math.rad(-15)
			),
			0.08, Enum.EasingStyle.Back
		)
	end
end

function Anim.JuggleSlam()
	-- Big overhead slam
	if RootJoint and OriginalC0.RootJoint then
		Anim.TweenJoint(RootJoint,
			OriginalC0.RootJoint * CFrame.new(0, -0.5, 0) * CFrame.Angles(math.rad(35), 0, 0),
			0.06, Enum.EasingStyle.Back
		)
	end
	if RightShoulder and OriginalC0.RightShoulder then
		Anim.TweenJoint(RightShoulder,
			OriginalC0.RightShoulder * CFrame.Angles(math.rad(50), 0, math.rad(20)),
			0.06, Enum.EasingStyle.Back
		)
	end
	if LeftShoulder and OriginalC0.LeftShoulder then
		Anim.TweenJoint(LeftShoulder,
			OriginalC0.LeftShoulder * CFrame.Angles(math.rad(50), 0, math.rad(-20)),
			0.06, Enum.EasingStyle.Back
		)
	end
end

-- ULTIMATE ANIMATIONS
function Anim.UltBow()
	State.Animating = true
	Anim.StopClownIdle()
	
	-- Theatrical bow
	if RootJoint and OriginalC0.RootJoint then
		Anim.TweenJoint(RootJoint,
			OriginalC0.RootJoint * CFrame.Angles(math.rad(45), 0, 0),
			0.3, Enum.EasingStyle.Sine
		)
	end
	if RightShoulder and OriginalC0.RightShoulder then
		Anim.TweenJoint(RightShoulder,
			OriginalC0.RightShoulder * CFrame.Angles(math.rad(20), 0, math.rad(60)),
			0.3, Enum.EasingStyle.Sine
		)
	end
	if LeftShoulder and OriginalC0.LeftShoulder then
		Anim.TweenJoint(LeftShoulder,
			OriginalC0.LeftShoulder * CFrame.Angles(math.rad(20), 0, math.rad(-60)),
			0.3, Enum.EasingStyle.Sine
		)
	end
	if Neck and OriginalC0.Neck then
		Anim.TweenJoint(Neck,
			OriginalC0.Neck * CFrame.Angles(math.rad(20), 0, 0),
			0.3
		)
	end
end

function Anim.UltTransform()
	-- T-Pose power up
	if RootJoint and OriginalC0.RootJoint then
		Anim.TweenJoint(RootJoint,
			OriginalC0.RootJoint * CFrame.new(0, 1, 0) * CFrame.Angles(math.rad(-10), 0, 0),
			0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out
		)
	end
	if RightShoulder and OriginalC0.RightShoulder then
		Anim.TweenJoint(RightShoulder,
			OriginalC0.RightShoulder * CFrame.Angles(0, 0, math.rad(90)),
			0.15, Enum.EasingStyle.Back
		)
	end
	if LeftShoulder and OriginalC0.LeftShoulder then
		Anim.TweenJoint(LeftShoulder,
			OriginalC0.LeftShoulder * CFrame.Angles(0, 0, math.rad(-90)),
			0.15, Enum.EasingStyle.Back
		)
	end
	if Neck and OriginalC0.Neck then
		Anim.TweenJoint(Neck,
			OriginalC0.Neck * CFrame.Angles(math.rad(-25), 0, 0),
			0.15
		)
	end
end

function Anim.UltBarrage()
	-- Rapid alternating punches
	State.Animating = true
	for i = 1, 20 do
		local side = i % 2 == 0
		
		if RightShoulder and OriginalC0.RightShoulder then
			RightShoulder.C0 = OriginalC0.RightShoulder * CFrame.Angles(
				math.rad(-90) + math.rad(math.random(-20, 20)),
				math.rad(side and -30 or 10),
				math.rad(math.random(-10, 10))
			)
		end
		if LeftShoulder and OriginalC0.LeftShoulder then
			LeftShoulder.C0 = OriginalC0.LeftShoulder * CFrame.Angles(
				math.rad(-90) + math.rad(math.random(-20, 20)),
				math.rad(side and -10 or 30),
				math.rad(math.random(-10, 10))
			)
		end
		if RootJoint and OriginalC0.RootJoint then
			RootJoint.C0 = OriginalC0.RootJoint * CFrame.Angles(
				math.rad(10),
				math.rad(side and 15 or -15),
				0
			)
		end
		
		wait(0.05)
	end
end

function Anim.UltMalletRaise()
	-- Arms way up holding mallet
	if RightShoulder and OriginalC0.RightShoulder then
		Anim.TweenJoint(RightShoulder,
			OriginalC0.RightShoulder * CFrame.Angles(math.rad(-175), math.rad(-10), math.rad(15)),
			0.15, Enum.EasingStyle.Back
		)
	end
	if LeftShoulder and OriginalC0.LeftShoulder then
		Anim.TweenJoint(LeftShoulder,
			OriginalC0.LeftShoulder * CFrame.Angles(math.rad(-175), math.rad(10), math.rad(-15)),
			0.15, Enum.EasingStyle.Back
		)
	end
	if RootJoint and OriginalC0.RootJoint then
		Anim.TweenJoint(RootJoint,
			OriginalC0.RootJoint * CFrame.new(0, 0.5, 0) * CFrame.Angles(math.rad(-15), 0, 0),
			0.15
		)
	end
end

function Anim.UltMalletSlam()
	-- Massive slam
	if RightShoulder and OriginalC0.RightShoulder then
		Anim.TweenJoint(RightShoulder,
			OriginalC0.RightShoulder * CFrame.Angles(math.rad(60), 0, math.rad(10)),
			0.04, Enum.EasingStyle.Quad
		)
	end
	if LeftShoulder and OriginalC0.LeftShoulder then
		Anim.TweenJoint(LeftShoulder,
			OriginalC0.LeftShoulder * CFrame.Angles(math.rad(60), 0, math.rad(-10)),
			0.04, Enum.EasingStyle.Quad
		)
	end
	if RootJoint and OriginalC0.RootJoint then
		Anim.TweenJoint(RootJoint,
			OriginalC0.RootJoint * CFrame.new(0, -0.8, 0) * CFrame.Angles(math.rad(40), 0, 0),
			0.04
		)
	end
	if Neck and OriginalC0.Neck then
		Anim.TweenJoint(Neck,
			OriginalC0.Neck * CFrame.Angles(math.rad(25), 0, 0),
			0.04
		)
	end
end

function Anim.BlockPose()
	State.Animating = true
	Anim.StopClownIdle()
	
	-- Cross arms guard
	if RightShoulder and OriginalC0.RightShoulder then
		Anim.TweenJoint(RightShoulder,
			OriginalC0.RightShoulder * CFrame.Angles(math.rad(-70), math.rad(-50), math.rad(15)),
			0.1
		)
	end
	if LeftShoulder and OriginalC0.LeftShoulder then
		Anim.TweenJoint(LeftShoulder,
			OriginalC0.LeftShoulder * CFrame.Angles(math.rad(-70), math.rad(50), math.rad(-15)),
			0.1
		)
	end
	if RootJoint and OriginalC0.RootJoint then
		Anim.TweenJoint(RootJoint,
			OriginalC0.RootJoint * CFrame.new(0, -0.15, 0) * CFrame.Angles(math.rad(8), 0, 0),
			0.1
		)
	end
end

function Anim.DashCartwheel()
	State.Animating = true
	Anim.StopClownIdle()
	
	-- Quick cartwheel spin
	spawn(function()
		local duration = 0.25
		local start = tick()
		while tick() - start < duration do
			local progress = (tick() - start) / duration
			local angle = progress * math.pi * 2
			
			if RootJoint and OriginalC0.RootJoint then
				RootJoint.C0 = OriginalC0.RootJoint * CFrame.Angles(0, 0, angle)
			end
			
			RunService.Heartbeat:Wait()
		end
		
		if RootJoint and OriginalC0.RootJoint then
			RootJoint.C0 = OriginalC0.RootJoint
		end
		
		State.Animating = false
	end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- VFX ENGINE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local VFX = {}

local COLORS = {
	Red = Color3.fromRGB(255, 50, 50),
	Gold = Color3.fromRGB(255, 215, 0),
	Purple = Color3.fromRGB(138, 43, 226),
	HotPink = Color3.fromRGB(255, 0, 100),
	Cyan = Color3.fromRGB(0, 255, 255),
	Orange = Color3.fromRGB(255, 165, 0),
	Pink = Color3.fromRGB(255, 105, 180),
	Cream = Color3.fromRGB(255, 255, 200),
	White = Color3.fromRGB(255, 255, 255),
	Green = Color3.fromRGB(0, 255, 100),
}

function VFX.Ring(pos, color, maxSize, dur)
	local ring = Instance.new("Part")
	ring.Anchored = true
	ring.CanCollide = false
	ring.Transparency = 0.3
	ring.Material = Enum.Material.Neon
	ring.Color = color
	ring.Shape = Enum.PartType.Cylinder
	ring.Size = Vector3.new(0.15, 0.1, 0.1)
	ring.CFrame = CFrame.new(pos) * CFrame.Angles(0, 0, math.rad(90))
	ring.Parent = workspace.Terrain
	
	TweenService:Create(ring, TweenInfo.new(dur or 0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Size = Vector3.new(0.15, maxSize or 20, maxSize or 20),
		Transparency = 1,
	}):Play()
	
	Debris:AddItem(ring, (dur or 0.5) + 0.1)
end

function VFX.Sphere(pos, color, maxSize, dur)
	local sphere = Instance.new("Part")
	sphere.Anchored = true
	sphere.CanCollide = false
	sphere.Transparency = 0.4
	sphere.Material = Enum.Material.ForceField
	sphere.Color = color
	sphere.Shape = Enum.PartType.Ball
	sphere.Size = Vector3.new(0.5, 0.5, 0.5)
	sphere.CFrame = CFrame.new(pos)
	sphere.Parent = workspace.Terrain
	
	TweenService:Create(sphere, TweenInfo.new(dur or 0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Size = Vector3.new(maxSize or 10, maxSize or 10, maxSize or 10),
		Transparency = 1,
	}):Play()
	
	Debris:AddItem(sphere, (dur or 0.4) + 0.1)
end

function VFX.Crack(pos, color, range)
	for i = 1, 10 do
		local angle = (i / 10) * math.pi * 2 + math.random() * 0.3
		local length = (range or 12) * (0.4 + math.random() * 0.6)
		
		local crack = Instance.new("Part")
		crack.Anchored = true
		crack.CanCollide = false
		crack.Material = Enum.Material.Neon
		crack.Color = color
		crack.Size = Vector3.new(length, 0.08, 0.2 + math.random() * 0.3)
		
		local dir = Vector3.new(math.cos(angle), 0, math.sin(angle))
		crack.CFrame = CFrame.new(pos + dir * length / 2, pos + dir * length)
		crack.Transparency = 1
		crack.Parent = workspace.Terrain
		
		TweenService:Create(crack, TweenInfo.new(0.08), {Transparency = 0}):Play()
		
		spawn(function()
			wait(0.8)
			TweenService:Create(crack, TweenInfo.new(0.5), {Transparency = 1}):Play()
		end)
		
		Debris:AddItem(crack, 1.5)
	end
end

function VFX.Flash(color, dur)
	local cc = Instance.new("ColorCorrectionEffect")
	cc.TintColor = color
	cc.Brightness = 0.4
	cc.Parent = Camera
	
	TweenService:Create(cc, TweenInfo.new(dur or 0.15), {Brightness = 0}):Play()
	Debris:AddItem(cc, (dur or 0.15) + 0.05)
end

function VFX.Shake(intensity, dur)
	spawn(function()
		local s = tick()
		while tick() - s < (dur or 0.3) do
			local p = 1 - ((tick() - s) / (dur or 0.3))
			local offset = Vector3.new(
				(math.random() - 0.5) * 2 * intensity * p,
				(math.random() - 0.5) * 2 * intensity * p,
				(math.random() - 0.5) * 2 * intensity * p
			)
			Camera.CFrame = Camera.CFrame * CFrame.new(offset)
			RunService.RenderStepped:Wait()
		end
	end)
end

function VFX.SlowMo(dur)
	spawn(function()
		local blur = Instance.new("BlurEffect")
		blur.Size = 8
		blur.Parent = Camera
		wait(dur or 0.4)
		TweenService:Create(blur, TweenInfo.new(0.2), {Size = 0}):Play()
		Debris:AddItem(blur, 0.3)
	end)
end

function VFX.Afterimage(character, color, count)
	spawn(function()
		for i = 1, (count or 3) do
			for _, part in pairs(character:GetChildren()) do
				if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
					local clone = Instance.new("Part")
					clone.Size = part.Size
					clone.CFrame = part.CFrame
					clone.Anchored = true
					clone.CanCollide = false
					clone.Material = Enum.Material.Neon
					clone.Color = color
					clone.Transparency = 0.5
					clone.Parent = workspace.Terrain
					
					TweenService:Create(clone, TweenInfo.new(0.3), {
						Transparency = 1,
						Size = part.Size * 1.2,
					}):Play()
					
					Debris:AddItem(clone, 0.35)
				end
			end
			wait(0.04)
		end
	end)
end

function VFX.BeamLine(startPos, endPos, color, dur)
	local dist = (endPos - startPos).Magnitude
	local mid = (startPos + endPos) / 2
	
	local beam = Instance.new("Part")
	beam.Anchored = true
	beam.CanCollide = false
	beam.Material = Enum.Material.Neon
	beam.Color = color
	beam.Size = Vector3.new(0.3, 0.3, dist)
	beam.CFrame = CFrame.new(mid, endPos)
	beam.Transparency = 0.2
	beam.Parent = workspace.Terrain
	
	TweenService:Create(beam, TweenInfo.new(dur or 0.3), {
		Transparency = 1,
		Size = Vector3.new(0.05, 0.05, dist),
	}):Play()
	
	Debris:AddItem(beam, (dur or 0.3) + 0.05)
end

function VFX.Debris(pos, count, color)
	for i = 1, (count or 8) do
		local chunk = Instance.new("Part")
		chunk.Size = Vector3.new(
			math.random() * 2 + 0.5,
			math.random() * 2 + 0.5,
			math.random() * 2 + 0.5
		)
		chunk.Material = Enum.Material.Slate
		chunk.Color = color or Color3.fromRGB(80, 80, 80)
		chunk.CFrame = CFrame.new(pos) * CFrame.Angles(math.random() * math.pi, math.random() * math.pi, 0)
		chunk.Parent = workspace.Terrain
		
		chunk.Velocity = Vector3.new(
			(math.random() - 0.5) * 80,
			math.random(30, 70),
			(math.random() - 0.5) * 80
		)
		chunk.RotVelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10))
		
		Debris:AddItem(chunk, 3)
		spawn(function()
			wait(2)
			if chunk.Parent then
				TweenService:Create(chunk, TweenInfo.new(1), {Transparency = 1}):Play()
			end
		end)
	end
end

function VFX.Aura(rootPart, color1, color2)
	-- Orbiting neon orbs as aura
	local auraFolder = Instance.new("Folder")
	auraFolder.Name = "ClownAura"
	auraFolder.Parent = rootPart
	
	for i = 1, 6 do
		local orb = Instance.new("Part")
		orb.Size = Vector3.new(0.8, 0.8, 0.8)
		orb.Shape = Enum.PartType.Ball
		orb.Material = Enum.Material.Neon
		orb.Color = i % 2 == 0 and color1 or color2
		orb.Anchored = true
		orb.CanCollide = false
		orb.Transparency = 0.3
		orb.Parent = auraFolder
		
		local light = Instance.new("PointLight")
		light.Color = orb.Color
		light.Brightness = 2
		light.Range = 8
		light.Parent = orb
	end
	
	-- Aura glow on character
	local mainLight = Instance.new("PointLight")
	mainLight.Name = "ClownMainGlow"
	mainLight.Color = color1
	mainLight.Brightness = 3
	mainLight.Range = 25
	mainLight.Parent = rootPart
	
	return auraFolder
end

function VFX.UpdateAura(auraFolder, rootPart, t)
	if not auraFolder or not auraFolder.Parent then return end
	
	local orbs = auraFolder:GetChildren()
	for i, orb in ipairs(orbs) do
		if orb:IsA("BasePart") then
			local angle = (i / #orbs) * math.pi * 2 + t * 3
			local height = math.sin(t * 4 + i) * 1.5
			local radius = 3 + math.sin(t * 2 + i * 0.5) * 0.5
			
			orb.CFrame = CFrame.new(
				rootPart.Position + Vector3.new(
					math.cos(angle) * radius,
					height,
					math.sin(angle) * radius
				)
			)
			
			orb.Size = Vector3.new(
				0.6 + math.sin(t * 5 + i) * 0.2,
				0.6 + math.sin(t * 5 + i) * 0.2,
				0.6 + math.sin(t * 5 + i) * 0.2
			)
		end
	end
end

function VFX.RemoveAura(rootPart)
	local aura = rootPart:FindFirstChild("ClownAura")
	if aura then aura:Destroy() end
	local glow = rootPart:FindFirstChild("ClownMainGlow")
	if glow then glow:Destroy() end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SFX
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local SFX = {}

function SFX.Play(id, parent, vol, pitch)
	local s = Instance.new("Sound")
	s.SoundId = id
	s.Volume = vol or 1
	s.PlaybackSpeed = pitch or 1
	s.Parent = parent or HumanoidRootPart
	s:Play()
	Debris:AddItem(s, s.TimeLength / s.PlaybackSpeed + 0.5)
	return s
end

-- Sound library
SFX.Lib = {
	Hit1 = "rbxassetid://5765826824",
	Hit2 = "rbxassetid://3932505367",
	HeavyHit = "rbxassetid://6579575873",
	Whoosh = "rbxassetid://6579546553",
	Honk = "rbxassetid://257001402",
	Pop = "rbxassetid://3716104522",
	Splat = "rbxassetid://3362285462",
	Squeak = "rbxassetid://292838651",
	Boom = "rbxassetid://6579575873",
	Charge = "rbxassetid://1837286840",
	Laugh = "rbxassetid://2919713060",
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- HITBOX UTILITY
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local function GetTarget(range)
	range = range or 8
	local closest, closestDist = nil, range
	for _, p in pairs(Players:GetPlayers()) do
		if p ~= Player and p.Character then
			local root = p.Character:FindFirstChild("HumanoidRootPart")
			local hum = p.Character:FindFirstChild("Humanoid")
			if root and hum and hum.Health > 0 then
				local d = (HumanoidRootPart.Position - root.Position).Magnitude
				if d < closestDist then
					closest = p.Character
					closestDist = d
				end
			end
		end
	end
	return closest, closestDist
end

local function GetTargetsInRadius(pos, radius)
	local targets = {}
	for _, p in pairs(Players:GetPlayers()) do
		if p ~= Player and p.Character then
			local root = p.Character:FindFirstChild("HumanoidRootPart")
			local hum = p.Character:FindFirstChild("Humanoid")
			if root and hum and hum.Health > 0 then
				if (pos - root.Position).Magnitude <= radius then
					table.insert(targets, p.Character)
				end
			end
		end
	end
	return targets
end

local function FaceTarget(targetRoot)
	if targetRoot and HumanoidRootPart then
		local dir = (targetRoot.Position - HumanoidRootPart.Position) * Vector3.new(1, 0, 1)
		if dir.Magnitude > 0.1 then
			HumanoidRootPart.CFrame = CFrame.new(HumanoidRootPart.Position, HumanoidRootPart.Position + dir)
		end
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- TOOL CREATION SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local Tools = {}

local function CreateToolBase(name, color, emoji)
	local tool = Instance.new("Tool")
	tool.Name = name
	tool.CanBeDropped = false
	tool.RequiresHandle = true
	
	local handle = Instance.new("Part")
	handle.Name = "Handle"
	handle.Size = Vector3.new(0.1, 0.1, 0.1)
	handle.Transparency = 1
	handle.CanCollide = false
	handle.Massless = true
	handle.Parent = tool
	
	-- Visual indicator on the handle (small glowing orb)
	local visual = Instance.new("Part")
	visual.Name = "Visual"
	visual.Size = Vector3.new(0.4, 0.4, 0.4)
	visual.Shape = Enum.PartType.Ball
	visual.Material = Enum.Material.Neon
	visual.Color = color
	visual.Transparency = 0.5
	visual.CanCollide = false
	visual.Massless = true
	visual.Parent = handle
	
	local weld = Instance.new("WeldConstraint")
	weld.Part0 = handle
	weld.Part1 = visual
	weld.Parent = visual
	visual.CFrame = handle.CFrame
	
	return tool
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ABILITY FUNCTIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- â–ˆâ–ˆ M1 COMBO â–ˆâ–ˆ
function Tools.M1Attack()
	if State.Attacking or State.UsingSkill then return end
	
	local now = tick()
	if now - State.M1LastTime > State.M1Window then
		State.M1Count = 0
	end
	
	State.M1Count = State.M1Count + 1
	if State.M1Count > 5 then State.M1Count = 1 end
	State.M1LastTime = now
	State.Attacking = true
	
	local target, dist = GetTarget(10)
	
	if target then
		FaceTarget(target:FindFirstChild("HumanoidRootPart"))
	end
	
	local hitTarget = target and dist and dist <= 10
	
	local combo = State.M1Count
	
	-- Play CFrame animation based on combo
	if combo == 1 then
		Anim.M1_Hit1()
	elseif combo == 2 then
		Anim.M1_Hit2()
	elseif combo == 3 then
		Anim.M1_Hit3()
	elseif combo == 4 then
		Anim.M1_Hit4()
	elseif combo == 5 then
		Anim.M1_Hit5()
	end
	
	-- Hit VFX
	if hitTarget then
		local tRoot = target:FindFirstChild("HumanoidRootPart")
		if tRoot then
			local hitPos = tRoot.Position + (HumanoidRootPart.Position - tRoot.Position).Unit * 1.5
			
			if combo <= 2 then
				VFX.Sphere(hitPos, COLORS.Red, 3, 0.2)
				SFX.Play(SFX.Lib.Hit1, tRoot, 0.8, 0.9 + math.random() * 0.2)
				VFX.Shake(0.3, 0.08)
			elseif combo == 3 then
				VFX.Sphere(hitPos, COLORS.Gold, 5, 0.3)
				VFX.Ring(hitPos, COLORS.Gold, 8, 0.25)
				SFX.Play(SFX.Lib.HeavyHit, tRoot, 1, 0.8)
				SFX.Play(SFX.Lib.Honk, tRoot, 0.4, 1.5)
				VFX.Shake(0.8, 0.12)
			elseif combo == 4 then
				VFX.Sphere(hitPos, COLORS.Purple, 6, 0.3)
				VFX.Ring(hitPos, COLORS.Purple, 10, 0.3)
				VFX.BeamLine(HumanoidRootPart.Position, tRoot.Position, COLORS.Purple, 0.2)
				SFX.Play(SFX.Lib.HeavyHit, tRoot, 1.2, 0.7)
				VFX.Shake(1.2, 0.15)
			elseif combo == 5 then
				-- BIG FINISHER
				VFX.Sphere(hitPos, COLORS.Red, 12, 0.5)
				VFX.Ring(hitPos, COLORS.Red, 18, 0.4)
				VFX.Ring(hitPos + Vector3.new(0, 2, 0), COLORS.Gold, 14, 0.35)
				VFX.Crack(hitPos, COLORS.Red, 10)
				VFX.Flash(COLORS.Red, 0.1)
				SFX.Play(SFX.Lib.HeavyHit, tRoot, 1.5, 0.5)
				SFX.Play(SFX.Lib.Honk, tRoot, 0.8, 0.6)
				SFX.Play(SFX.Lib.Boom, tRoot, 1, 0.7)
				VFX.Shake(2.5, 0.3)
				VFX.Afterimage(Character, COLORS.Red, 2)
			end
			
			State.UltMeter = math.min(State.UltMeter + 4, State.UltMax)
		end
	else
		-- Whiff
		SFX.Play(SFX.Lib.Whoosh, nil, 0.4, 1 + math.random() * 0.3)
	end
	
	-- Recovery
	local recoveries = {0.3, 0.3, 0.35, 0.35, 0.5}
	wait(recoveries[combo] or 0.3)
	
	Anim.ResetPose(0.15)
	State.Attacking = false
	State.Animating = false
	Anim.StartClownIdle()
end

-- â–ˆâ–ˆ SKILL 1: PIE TO THE FACE [E] â–ˆâ–ˆ
function Tools.Skill1_Pie()
	if State.UsingSkill or State.Attacking then return end
	if State.Cooldowns.Skill1 > tick() then return end
	
	State.UsingSkill = true
	State.Cooldowns.Skill1 = tick() + State.CooldownDurations.Skill1
	
	-- Windup
	Anim.PieWindup()
	SFX.Play(SFX.Lib.Whoosh, nil, 0.5, 0.8)
	wait(0.18)
	
	-- Throw
	Anim.PieThrow()
	SFX.Play(SFX.Lib.Whoosh, nil, 1, 1.2)
	
	-- Create pie projectile
	local startPos = HumanoidRootPart.Position + HumanoidRootPart.CFrame.LookVector * 3 + Vector3.new(0, 2, 0)
	local dir = HumanoidRootPart.CFrame.LookVector
	
	-- Pie part
	local pie = Instance.new("Part")
	pie.Size = Vector3.new(2.5, 0.5, 2.5)
	pie.Shape = Enum.PartType.Cylinder
	pie.Material = Enum.Material.SmoothPlastic
	pie.Color = COLORS.Cream
	pie.Anchored = false
	pie.CanCollide = false
	pie.CFrame = CFrame.new(startPos, startPos + dir) * CFrame.Angles(0, 0, math.rad(90))
	pie.Parent = workspace.Terrain
	
	-- Cream on top
	local cream = Instance.new("Part")
	cream.Size = Vector3.new(2, 1, 2)
	cream.Shape = Enum.PartType.Ball
	cream.Material = Enum.Material.SmoothPlastic
	cream.Color = COLORS.White
	cream.CanCollide = false
	cream.Massless = true
	cream.Parent = workspace.Terrain
	
	local creamWeld = Instance.new("WeldConstraint")
	creamWeld.Part0 = pie
	creamWeld.Part1 = cream
	creamWeld.Parent = cream
	cream.CFrame = pie.CFrame * CFrame.new(0, 0.5, 0)
	
	-- Velocity
	local bv = Instance.new("BodyVelocity")
	bv.Velocity = dir * 110
	bv.MaxForce = Vector3.new(1e8, 1e8, 1e8)
	bv.Parent = pie
	
	-- Spin
	local spin = Instance.new("BodyAngularVelocity")
	spin.AngularVelocity = Vector3.new(0, 25, 0)
	spin.MaxTorque = Vector3.new(1e8, 1e8, 1e8)
	spin.Parent = pie
	
	Debris:AddItem(pie, 2.5)
	Debris:AddItem(cream, 2.5)
	
	-- Pie hit detection
	local hit = false
	pie.Touched:Connect(function(part)
		if hit then return end
		local hitChar = part.Parent
		if hitChar and hitChar ~= Character and hitChar:FindFirstChild("Humanoid") then
			hit = true
			local hitPos = pie.Position
			
			-- SPLAT!!!
			VFX.Sphere(hitPos, COLORS.Cream, 8, 0.5)
			VFX.Sphere(hitPos, COLORS.White, 6, 0.4)
			VFX.Ring(hitPos, COLORS.Gold, 10, 0.4)
			
			-- Cream splatter
			for j = 1, 12 do
				local splat = Instance.new("Part")
				splat.Size = Vector3.new(math.random() * 1 + 0.3, math.random() * 1 + 0.3, math.random() * 1 + 0.3)
				splat.Shape = Enum.PartType.Ball
				splat.Material = Enum.Material.SmoothPlastic
				splat.Color = j % 2 == 0 and COLORS.White or COLORS.Cream
				splat.CFrame = CFrame.new(hitPos)
				splat.CanCollide = true
				splat.Parent = workspace.Terrain
				splat.Velocity = Vector3.new(
					(math.random() - 0.5) * 60,
					math.random(10, 40),
					(math.random() - 0.5) * 60
				)
				Debris:AddItem(splat, 2)
				spawn(function()
					wait(1.5)
					if splat.Parent then
						TweenService:Create(splat, TweenInfo.new(0.5), {Transparency = 1}):Play()
					end
				end)
			end
			
			SFX.Play(SFX.Lib.Splat, nil, 1.5, 0.8 + math.random() * 0.4)
			SFX.Play(SFX.Lib.Honk, nil, 0.6, 1.3)
			VFX.Shake(2, 0.3)
			VFX.Flash(COLORS.Cream, 0.1)
			
			State.UltMeter = math.min(State.UltMeter + 8, State.UltMax)
			
			pie:Destroy()
			cream:Destroy()
		end
	end)
	
	wait(0.3)
	Anim.ResetPose(0.2)
	State.UsingSkill = false
	State.Animating = false
	Anim.StartClownIdle()
end

-- â–ˆâ–ˆ SKILL 2: BALLOON ANIMAL BARRAGE [R] â–ˆâ–ˆ
function Tools.Skill2_Balloons()
	if State.UsingSkill or State.Attacking then return end
	if State.Cooldowns.Skill2 > tick() then return end
	
	State.UsingSkill = true
	State.Cooldowns.Skill2 = tick() + State.CooldownDurations.Skill2
	
	-- Twist animation
	Anim.BalloonTwist()
	SFX.Play(SFX.Lib.Squeak, nil, 0.6, 1)
	SFX.Play(SFX.Lib.Squeak, nil, 0.4, 1.3)
	wait(0.3)
	SFX.Play(SFX.Lib.Squeak, nil, 0.5, 0.8)
	wait(0.15)
	
	-- Launch
	Anim.BalloonLaunch()
	SFX.Play(SFX.Lib.Whoosh, nil, 1, 0.8)
	
	local baseDir = HumanoidRootPart.CFrame.LookVector
	local startPos = HumanoidRootPart.Position + baseDir * 2 + Vector3.new(0, 3, 0)
	
	local balloonColors = {
		COLORS.Pink, COLORS.Cyan, COLORS.Gold,
		COLORS.Green, COLORS.Orange, COLORS.Purple,
	}
	
	for i = 1, 6 do
		spawn(function()
			wait((i - 1) * 0.07)
			
			local spread = ((i - 3.5) / 6) * math.rad(35)
			local dir = (CFrame.Angles(0, spread, 0) * CFrame.new(0, 0, -1)).Position
			dir = (CFrame.new(Vector3.new(), baseDir) * CFrame.new(dir)).Position.Unit
			
			local balloon = Instance.new("Part")
			balloon.Size = Vector3.new(1.5, 1.5, 3)
			balloon.Material = Enum.Material.SmoothPlastic
			balloon.Color = balloonColors[i]
			balloon.Transparency = 0.15
			balloon.CanCollide = false
			balloon.Anchored = false
			balloon.CFrame = CFrame.new(startPos + Vector3.new((math.random() - 0.5) * 2, (math.random() - 0.5), 0), startPos + dir * 10)
			balloon.Parent = workspace.Terrain
			
			local mesh = Instance.new("SpecialMesh")
			mesh.MeshType = Enum.MeshType.Sphere
			mesh.Scale = Vector3.new(1, 0.8, 1.8)
			mesh.Parent = balloon
			
			-- Glow
			local glow = Instance.new("PointLight")
			glow.Color = balloonColors[i]
			glow.Brightness = 2
			glow.Range = 6
			glow.Parent = balloon
			
			-- Velocity
			local bv = Instance.new("BodyVelocity")
			bv.Velocity = dir * 85
			bv.MaxForce = Vector3.new(1e8, 1e8, 1e8)
			bv.Parent = balloon
			
			Debris:AddItem(balloon, 2)
			
			local popped = false
			balloon.Touched:Connect(function(part)
				if popped then return end
				local hitChar = part.Parent
				if hitChar and hitChar ~= Character and hitChar:FindFirstChild("Humanoid") then
					popped = true
					
					VFX.Sphere(balloon.Position, balloonColors[i], 5, 0.25)
					VFX.Ring(balloon.Position, balloonColors[i], 7, 0.2)
					SFX.Play(SFX.Lib.Pop, balloon, 1, 0.8 + math.random() * 0.4)
					VFX.Shake(0.4, 0.06)
					
					balloon:Destroy()
				end
			end)
		end)
	end
	
	State.UltMeter = math.min(State.UltMeter + 8, State.UltMax)
	
	wait(0.5)
	Anim.ResetPose(0.2)
	State.UsingSkill = false
	State.Animating = false
	Anim.StartClownIdle()
end

-- â–ˆâ–ˆ SKILL 3: HONK SHOCKWAVE [T] â–ˆâ–ˆ
function Tools.Skill3_Honk()
	if State.UsingSkill or State.Attacking then return end
	if State.Cooldowns.Skill3 > tick() then return end
	
	State.UsingSkill = true
	State.Cooldowns.Skill3 = tick() + State.CooldownDurations.Skill3
	
	-- Inhale charge
	Anim.HonkInhale()
	SFX.Play(SFX.Lib.Charge, nil, 0.8, 1.5)
	
	-- Charge sphere growing
	local chargeSphere = Instance.new("Part")
	chargeSphere.Anchored = true
	chargeSphere.CanCollide = false
	chargeSphere.Transparency = 0.5
	chargeSphere.Material = Enum.Material.ForceField
	chargeSphere.Color = COLORS.Orange
	chargeSphere.Shape = Enum.PartType.Ball
	chargeSphere.Size = Vector3.new(1, 1, 1)
	chargeSphere.CFrame = CFrame.new(HumanoidRootPart.Position)
	chargeSphere.Parent = workspace.Terrain
	
	TweenService:Create(chargeSphere, TweenInfo.new(0.5), {
		Size = Vector3.new(6, 6, 6),
		Transparency = 0.3,
	}):Play()
	
	-- Charge shake
	spawn(function()
		for j = 1, 5 do
			VFX.Shake(0.2 + j * 0.1, 0.06)
			wait(0.1)
		end
	end)
	
	wait(0.6)
	
	-- RELEASE THE HONK
	Anim.HonkRelease()
	chargeSphere:Destroy()
	
	-- THE HONK
	SFX.Play(SFX.Lib.Honk, nil, 2.5, 0.4)
	SFX.Play(SFX.Lib.Boom, nil, 2, 0.5)
	
	local pos = HumanoidRootPart.Position
	
	-- Multiple expanding rings
	for j = 1, 6 do
		spawn(function()
			wait(j * 0.04)
			VFX.Ring(pos + Vector3.new(0, (j - 3) * 1.5, 0), COLORS.Orange, 30 + j * 4, 0.7)
		end)
	end
	
	VFX.Sphere(pos, COLORS.Gold, 20, 0.5)
	VFX.Sphere(pos, COLORS.Orange, 15, 0.4)
	VFX.Crack(pos, COLORS.Orange, 18)
	VFX.Flash(COLORS.Orange, 0.15)
	VFX.Shake(4, 0.5)
	VFX.Debris(pos, 10, COLORS.Orange)
	
	-- Hit all nearby
	local targets = GetTargetsInRadius(pos, 22)
	for _, t in pairs(targets) do
		local tRoot = t:FindFirstChild("HumanoidRootPart")
		if tRoot then
			VFX.Sphere(tRoot.Position, COLORS.Orange, 5, 0.3)
			VFX.BeamLine(pos, tRoot.Position, COLORS.Gold, 0.3)
		end
	end
	
	State.UltMeter = math.min(State.UltMeter + 12, State.UltMax)
	
	wait(0.4)
	Anim.ResetPose(0.25)
	State.UsingSkill = false
	State.Animating = false
	Anim.StartClownIdle()
end

-- â–ˆâ–ˆ SKILL 4: JUGGLING FRENZY [F] â–ˆâ–ˆ
function Tools.Skill4_Juggle()
	if State.UsingSkill or State.Attacking then return end
	if State.Cooldowns.Skill4 > tick() then return end
	
	local target, dist = GetTarget(14)
	if not target then return end
	
	State.UsingSkill = true
	State.Cooldowns.Skill4 = tick() + State.CooldownDurations.Skill4
	
	local tRoot = target:FindFirstChild("HumanoidRootPart")
	if not tRoot then
		State.UsingSkill = false
		return
	end
	
	FaceTarget(tRoot)
	
	-- Grab lunge
	Anim.GrabLunge()
	SFX.Play(SFX.Lib.Whoosh, nil, 1, 0.8)
	SFX.Play(SFX.Lib.Laugh, nil, 0.5, 1.2)
	
	VFX.Ring(HumanoidRootPart.Position, COLORS.Gold, 8, 0.3)
	VFX.Afterimage(Character, COLORS.Gold, 2)
	
	wait(0.15)
	
	-- Stars around target
	local stars = {}
	for j = 1, 4 do
		local star = Instance.new("Part")
		star.Size = Vector3.new(0.8, 0.1, 0.8)
		star.Material = Enum.Material.Neon
		star.Color = COLORS.Gold
		star.Anchored = true
		star.CanCollide = false
		star.Parent = workspace.Terrain
		table.insert(stars, star)
	end
	
	-- Juggle sequence - 5 tosses
	local sides = {"right", "left", "right", "left", "slam"}
	local juggleColors = {COLORS.Gold, COLORS.Pink, COLORS.Cyan, COLORS.Purple, COLORS.Red}
	
	for j = 1, 5 do
		if j < 5 then
			Anim.JuggleToss(sides[j])
			
			-- Update star positions
			for si, star in pairs(stars) do
				if tRoot and tRoot.Parent then
					local a = (si / 4) * math.pi * 2 + j * 1.5
					star.CFrame = CFrame.new(
						tRoot.Position + Vector3.new(
							math.cos(a) * 2.5,
							math.sin(j * 2 + si) * 2,
							math.sin(a) * 2.5
						)
					)
				end
			end
			
			VFX.Sphere(tRoot.Position + Vector3.new(0, j * 2, 0), juggleColors[j], 4 + j, 0.25)
			SFX.Play(SFX.Lib.Hit1, tRoot, 0.8, 0.7 + j * 0.15)
			if j % 2 == 0 then
				SFX.Play(SFX.Lib.Honk, tRoot, 0.3, 1 + j * 0.2)
			end
			VFX.Shake(0.5 + j * 0.2, 0.08)
			
			wait(0.22)
		else
			-- FINAL SLAM
			Anim.JuggleSlam()
			wait(0.08)
			
			SFX.Play(SFX.Lib.HeavyHit, tRoot, 2, 0.5)
			SFX.Play(SFX.Lib.Boom, tRoot, 1.5, 0.6)
			SFX.Play(SFX.Lib.Honk, tRoot, 1, 0.5)
			
			VFX.Sphere(tRoot.Position, COLORS.Red, 15, 0.5)
			VFX.Ring(tRoot.Position, COLORS.Gold, 20, 0.4)
			VFX.Ring(tRoot.Position + Vector3.new(0, 1, 0), COLORS.Red, 16, 0.35)
			VFX.Crack(tRoot.Position, COLORS.Red, 15)
			VFX.Flash(COLORS.Gold, 0.15)
			VFX.Shake(3.5, 0.4)
			VFX.Debris(tRoot.Position, 8)
		end
	end
	
	-- Clean up stars
	for _, star in pairs(stars) do
		TweenService:Create(star, TweenInfo.new(0.3), {Transparency = 1}):Play()
		Debris:AddItem(star, 0.35)
	end
	
	State.UltMeter = math.min(State.UltMeter + 15, State.UltMax)
	
	wait(0.3)
	Anim.ResetPose(0.25)
	State.UsingSkill = false
	State.Animating = false
	Anim.StartClownIdle()
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- â–ˆâ–ˆ ULTIMATE: ğŸª THE BIG TOP ğŸª [G] â–ˆâ–ˆ
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function Tools.Ultimate()
	if State.UltActive then return end
	if State.UsingSkill or State.Attacking then return end
	if State.UltMeter < State.UltMax then return end
	if State.Cooldowns.Ultimate > tick() then return end
	
	State.UltActive = true
	State.UsingSkill = true
	State.UltMeter = 0
	State.Cooldowns.Ultimate = tick() + State.CooldownDurations.Ultimate
	
	-- â•â•â• PHASE 1: THEATRICAL BOW â•â•â•
	Anim.UltBow()
	SFX.Play(SFX.Lib.Charge, nil, 1.5, 0.5)
	
	-- Darken screen
	local cc = Instance.new("ColorCorrectionEffect")
	cc.Brightness = 0
	cc.Saturation = 0
	cc.Contrast = 0
	cc.Parent = Camera
	
	TweenService:Create(cc, TweenInfo.new(0.4), {
		Brightness = -0.5,
		Saturation = -0.7,
		Contrast = 0.2,
	}):Play()
	
	-- Spotlight
	local spotPart = Instance.new("Part")
	spotPart.Anchored = true
	spotPart.CanCollide = false
	spotPart.Transparency = 1
	spotPart.Position = HumanoidRootPart.Position + Vector3.new(0, 25, 0)
	spotPart.Parent = workspace.Terrain
	
	local spotlight = Instance.new("SpotLight")
	spotlight.Brightness = 8
	spotlight.Range = 50
	spotlight.Angle = 40
	spotlight.Color = COLORS.HotPink
	spotlight.Face = Enum.NormalId.Bottom
	spotlight.Parent = spotPart
	
	wait(0.8)
	
	-- â•â•â• PHASE 2: AWAKENING TRANSFORMATION â•â•â•
	Anim.UltTransform()
	SFX.Play(SFX.Lib.Laugh, nil, 2, 0.6)
	SFX.Play(SFX.Lib.Boom, nil, 2, 0.3)
	
	-- Massive VFX explosion
	VFX.Sphere(HumanoidRootPart.Position, COLORS.HotPink, 40, 0.8)
	VFX.Sphere(HumanoidRootPart.Position, COLORS.Cyan, 25, 0.6)
	
	for j = 1, 8 do
		spawn(function()
			wait(j * 0.03)
			VFX.Ring(HumanoidRootPart.Position + Vector3.new(0, j * 2 - 8, 0), COLORS.HotPink, 35, 0.5 + j * 0.04)
		end)
	end
	
	VFX.Crack(HumanoidRootPart.Position, COLORS.HotPink, 25)
	VFX.Flash(COLORS.HotPink, 0.2)
	VFX.Shake(5, 1)
	VFX.Debris(HumanoidRootPart.Position, 15, COLORS.Purple)
	
	-- Lightning bolts
	for j = 1, 8 do
		local angle = (j / 8) * math.pi * 2
		local endPos = HumanoidRootPart.Position + Vector3.new(math.cos(angle) * 15, 20, math.sin(angle) * 15)
		VFX.BeamLine(HumanoidRootPart.Position, endPos, COLORS.Cyan, 0.5)
	end
	
	-- Create awakened aura
	State.Awakened = true
	local auraFolder = VFX.Aura(HumanoidRootPart, COLORS.HotPink, COLORS.Cyan)
	
	-- Aura update connection
	local auraT = 0
	local auraConn = RunService.Heartbeat:Connect(function(dt)
		auraT = auraT + dt
		VFX.UpdateAura(auraFolder, HumanoidRootPart, auraT)
	end)
	
	-- Restore visuals but dramatic
	TweenService:Create(cc, TweenInfo.new(0.3), {
		Brightness = 0.05,
		Saturation = 0.6,
		Contrast = 0.15,
	}):Play()
	
	-- Show ult text
	spawn(function()
		Tools.ShowUltText("ğŸª THE BIG TOP ğŸª")
	end)
	
	wait(0.5)
	
	-- â•â•â• PHASE 3: SEEK AND DESTROY â•â•â•
	local target, tdist = GetTarget(60)
	
	if target then
		local tRoot = target:FindFirstChild("HumanoidRootPart")
		
		if tRoot then
			-- Teleport behind
			VFX.Sphere(HumanoidRootPart.Position, COLORS.HotPink, 8, 0.3)
			SFX.Play(SFX.Lib.Whoosh, nil, 1.5, 0.5)
			VFX.Afterimage(Character, COLORS.HotPink, 3)
			
			wait(0.08)
			
			-- Appear behind
			local behindPos = tRoot.Position - tRoot.CFrame.LookVector * 4
			HumanoidRootPart.CFrame = CFrame.new(behindPos, tRoot.Position)
			
			VFX.Sphere(HumanoidRootPart.Position, COLORS.Cyan, 6, 0.2)
			SFX.Play(SFX.Lib.Honk, nil, 0.5, 0.3) -- Deep menacing honk
			
			wait(0.1)
			
			-- â•â•â• BARRAGE â•â•â•
			Anim.UltBarrage()
			
			-- 20 rapid hits with VFX
			for j = 1, 20 do
				spawn(function()
					wait(j * 0.05)
					if not tRoot or not tRoot.Parent then return end
					
					local color = j % 3 == 0 and COLORS.Cyan or (j % 2 == 0 and COLORS.HotPink or COLORS.Purple)
					local hitPos = tRoot.Position + Vector3.new(
						(math.random() - 0.5) * 3,
						(math.random() - 0.5) * 3,
						(math.random() - 0.5) * 3
					)
					
					VFX.Sphere(hitPos, color, 3 + math.random() * 2, 0.12)
					
					if j % 3 == 0 then
						VFX.Ring(hitPos, color, 7, 0.15)
						SFX.Play(SFX.Lib.Honk, tRoot, 0.2, 0.8 + math.random() * 1.2)
					end
					
					if j % 5 == 0 then
						VFX.BeamLine(HumanoidRootPart.Position, hitPos, color, 0.1)
					end
					
					SFX.Play(SFX.Lib.Hit1, tRoot, 0.3 + (j / 20) * 0.3, 0.7 + math.random() * 0.6)
					VFX.Shake(0.3 + (j / 20) * 0.5, 0.03)
				end)
			end
			
			wait(1.1)
			
			-- â•â•â• PHASE 4: GIANT MALLET FINISHER â•â•â•
			VFX.SlowMo(0.4)
			SFX.Play(SFX.Lib.Charge, nil, 1, 2)
			
			-- Mallet raise animation
			Anim.UltMalletRaise()
			
			wait(0.25)
			
			-- Create giant mallet
			local malletHandle = Instance.new("Part")
			malletHandle.Size = Vector3.new(1.5, 18, 1.5)
			malletHandle.Material = Enum.Material.SmoothPlastic
			malletHandle.Color = COLORS.Red
			malletHandle.Anchored = true
			malletHandle.CanCollide = false
			malletHandle.CFrame = CFrame.new(tRoot.Position + Vector3.new(0, 30, 0))
			malletHandle.Parent = workspace.Terrain
			
			local malletHead = Instance.new("Part")
			malletHead.Size = Vector3.new(10, 7, 10)
			malletHead.Material = Enum.Material.SmoothPlastic
			malletHead.Color = COLORS.Gold
			malletHead.Anchored = true
			malletHead.CanCollide = false
			malletHead.CFrame = malletHandle.CFrame * CFrame.new(0, -12, 0)
			malletHead.Parent = workspace.Terrain
			
			-- Mallet glow
			local malletGlow = Instance.new("PointLight")
			malletGlow.Color = COLORS.HotPink
			malletGlow.Brightness = 5
			malletGlow.Range = 35
			malletGlow.Parent = malletHead
			
			-- Stars orbiting mallet
			for j = 1, 4 do
				local star = Instance.new("Part")
				star.Size = Vector3.new(1, 1, 1)
				star.Shape = Enum.PartType.Ball
				star.Material = Enum.Material.Neon
				star.Color = COLORS.Cyan
				star.Anchored = true
				star.CanCollide = false
				star.Parent = workspace.Terrain
				
				local a = (j / 4) * math.pi * 2
				star.CFrame = CFrame.new(malletHead.Position + Vector3.new(math.cos(a) * 5, 0, math.sin(a) * 5))
				
				Debris:AddItem(star, 1.5)
			end
			
			wait(0.2)
			
			-- SLAM ANIMATION
			Anim.UltMalletSlam()
			SFX.Play(SFX.Lib.Whoosh, nil, 2.5, 0.3)
			
			local slamTarget = tRoot.Position
			
			-- Mallet comes down
			TweenService:Create(malletHandle, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
				CFrame = CFrame.new(slamTarget + Vector3.new(0, 9, 0))
			}):Play()
			TweenService:Create(malletHead, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
				CFrame = CFrame.new(slamTarget + Vector3.new(0, -2, 0))
			}):Play()
			
			wait(0.22)
			
			-- â•â•â• MASSIVE IMPACT â•â•â•
			SFX.Play(SFX.Lib.HeavyHit, nil, 3, 0.3)
			SFX.Play(SFX.Lib.Boom, nil, 3, 0.2)
			SFX.Play(SFX.Lib.Honk, nil, 3, 0.2)
			
			VFX.Flash(Color3.new(1, 1, 1), 0.3)
			VFX.Shake(10, 1.5)
			
			-- Rising rings
			for j = 1, 12 do
				spawn(function()
					wait(j * 0.025)
					VFX.Ring(slamTarget + Vector3.new(0, j * 2.5, 0), 
						j % 2 == 0 and COLORS.HotPink or COLORS.Cyan, 25, 0.4 + j * 0.02)
				end)
			end
			
			-- Massive impact sphere
			VFX.Sphere(slamTarget, COLORS.HotPink, 50, 1.2)
			VFX.Sphere(slamTarget, COLORS.Cyan, 35, 1)
			VFX.Sphere(slamTarget, COLORS.Gold, 25, 0.8)
			
			-- Giant crater
			VFX.Crack(slamTarget, COLORS.HotPink, 35)
			
			-- Debris everywhere
			VFX.Debris(slamTarget, 25, nil)
			
			-- Lightning from impact point
			for j = 1, 12 do
				local a = (j / 12) * math.pi * 2
				local endP = slamTarget + Vector3.new(math.cos(a) * 20, math.random(5, 15), math.sin(a) * 20)
				VFX.BeamLine(slamTarget, endP, COLORS.Cyan, 0.4)
			end
			
			-- Mallet shatters
			spawn(function()
				wait(0.4)
				VFX.Sphere(malletHead.Position, COLORS.Gold, 18, 0.4)
				
				-- Shatter pieces
				for j = 1, 15 do
					local piece = Instance.new("Part")
					piece.Size = Vector3.new(
						math.random() * 2.5 + 0.5,
						math.random() * 2.5 + 0.5,
						math.random() * 2.5 + 0.5
					)
					piece.Material = Enum.Material.SmoothPlastic
					piece.Color = j % 3 == 0 and COLORS.Red or (j % 2 == 0 and COLORS.Gold or COLORS.HotPink)
					piece.CFrame = CFrame.new(malletHead.Position) * CFrame.Angles(math.random() * 6, math.random() * 6, 0)
					piece.Parent = workspace.Terrain
					piece.Velocity = Vector3.new(
						(math.random() - 0.5) * 100,
						math.random(40, 90),
						(math.random() - 0.5) * 100
					)
					piece.RotVelocity = Vector3.new(math.random(-12, 12), math.random(-12, 12), math.random(-12, 12))
					
					-- Glow on pieces
					local pLight = Instance.new("PointLight")
					pLight.Color = piece.Color
					pLight.Brightness = 2
					pLight.Range = 5
					pLight.Parent = piece
					
					Debris:AddItem(piece, 3)
					spawn(function()
						wait(2)
						if piece.Parent then
							TweenService:Create(piece, TweenInfo.new(1), {Transparency = 1}):Play()
						end
					end)
				end
				
				SFX.Play(SFX.Lib.Pop, nil, 2, 0.5)
				malletHandle:Destroy()
				malletHead:Destroy()
			end)
		end
	end
	
	-- â•â•â• PHASE 5: COOL DOWN â•â•â•
	wait(2)
	
	State.Awakened = false
	
	-- Remove aura
	if auraConn then auraConn:Disconnect() end
	VFX.RemoveAura(HumanoidRootPart)
	
	-- Remove spotlight
	if spotPart and spotPart.Parent then spotPart:Destroy() end
	
	-- Restore visuals
	TweenService:Create(cc, TweenInfo.new(0.8), {
		Brightness = 0,
		Saturation = 0,
		Contrast = 0,
	}):Play()
	Debris:AddItem(cc, 0.9)
	
	-- Victory pose
	Anim.ResetPose(0.3)
	wait(0.1)
	
	-- Bow
	Anim.UltBow()
	SFX.Play(SFX.Lib.Laugh, nil, 1, 0.9)
	
	wait(1)
	
	Anim.ResetPose(0.3)
	State.UltActive = false
	State.UsingSkill = false
	State.Animating = false
	Anim.StartClownIdle()
end

-- Ultimate text
function Tools.ShowUltText(text)
	local pg = Player:FindFirstChild("PlayerGui")
	if not pg then return end
	
	local sg = Instance.new("ScreenGui")
	sg.Name = "UltTextGui"
	sg.Parent = pg
	
	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 0.25, 0)
	label.Position = UDim2.new(0, 0, 0.38, 0)
	label.BackgroundTransparency = 1
	label.Text = text
	label.TextColor3 = COLORS.HotPink
	label.TextStrokeColor3 = Color3.new(0, 0, 0)
	label.TextStrokeTransparency = 0
	label.Font = Enum.Font.GothamBlack
	label.TextSize = 0
	label.TextTransparency = 0
	label.Parent = sg
	
	-- Scale in
	TweenService:Create(label, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		TextSize = 72,
	}):Play()
	
	-- Color cycle
	spawn(function()
		local colors = {COLORS.HotPink, COLORS.Cyan, COLORS.Gold, COLORS.Purple}
		for j = 1, 8 do
			wait(0.2)
			if label.Parent then
				TweenService:Create(label, TweenInfo.new(0.2), {
					TextColor3 = colors[(j % #colors) + 1]
				}):Play()
			end
		end
	end)
	
	wait(2)
	
	TweenService:Create(label, TweenInfo.new(0.4), {
		TextTransparency = 1,
		TextStrokeTransparency = 1,
		TextSize = 100,
	}):Play()
	
	Debris:AddItem(sg, 2.5)
end

-- â–ˆâ–ˆ DASH [Q] â–ˆâ–ˆ
function Tools.Dash()
	if State.Dashing then return end
	if State.UsingSkill then return end
	
	State.Dashing = true
	
	Anim.DashCartwheel()
	
	local moveDir = Humanoid.MoveDirection
	if moveDir.Magnitude < 0.1 then
		moveDir = HumanoidRootPart.CFrame.LookVector
	end
	
	VFX.Afterimage(Character, COLORS.Purple, 3)
	VFX.Ring(HumanoidRootPart.Position, COLORS.Purple, 8, 0.25)
	SFX.Play(SFX.Lib.Whoosh, nil, 0.8, 1.3)
	
	local bv = Instance.new("BodyVelocity")
	bv.Velocity = moveDir * 85
	bv.MaxForce = Vector3.new(1e8, 0, 1e8)
	bv.Parent = HumanoidRootPart
	Debris:AddItem(bv, 0.2)
	
	wait(0.3)
	State.Dashing = false
end

-- â–ˆâ–ˆ BLOCK â–ˆâ–ˆ
function Tools.StartBlock()
	if State.UsingSkill or State.Attacking then return end
	State.Blocking = true
	Anim.BlockPose()
	
	-- Block shield visual
	local shield = Instance.new("Part")
	shield.Name = "ClownShield"
	shield.Shape = Enum.PartType.Ball
	shield.Size = Vector3.new(7, 7, 7)
	shield.Material = Enum.Material.ForceField
	shield.Color = COLORS.Gold
	shield.Transparency = 0.6
	shield.Anchored = false
	shield.CanCollide = false
	shield.Massless = true
	shield.Parent = workspace.Terrain
	
	local weld = Instance.new("WeldConstraint")
	weld.Part0 = HumanoidRootPart
	weld.Part1 = shield
	weld.Parent = shield
	shield.CFrame = HumanoidRootPart.CFrame
	
	-- Pulse
	spawn(function()
		while State.Blocking and shield.Parent do
			TweenService:Create(shield, TweenInfo.new(0.4, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
				Transparency = 0.4,
				Size = Vector3.new(8, 8, 8),
			}):Play()
			wait(0.4)
			if not State.Blocking then break end
			TweenService:Create(shield, TweenInfo.new(0.4, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
				Transparency = 0.7,
				Size = Vector3.new(6.5, 6.5, 6.5),
			}):Play()
			wait(0.4)
		end
	end)
end

function Tools.StopBlock()
	State.Blocking = false
	
	for _, obj in pairs(workspace.Terrain:GetChildren()) do
		if obj.Name == "ClownShield" then
			TweenService:Create(obj, TweenInfo.new(0.15), {Transparency = 1}):Play()
			Debris:AddItem(obj, 0.2)
		end
	end
	
	Anim.ResetPose(0.15)
	State.Animating = false
	Anim.StartClownIdle()
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- TOOL CREATION & BACKPACK REPLACEMENT
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local function ClearExistingTools()
	-- Remove existing tools from backpack and character
	local backpack = Player:FindFirstChild("Backpack")
	if backpack then
		for _, item in pairs(backpack:GetChildren()) do
			if item:IsA("Tool") then
				item:Destroy()
			end
		end
	end
	
	if Character then
		for _, item in pairs(Character:GetChildren()) do
			if item:IsA("Tool") then
				item:Destroy()
			end
		end
	end
end

local function CreateClownTools()
	local backpack = Player:WaitForChild("Backpack")
	
	-- Wait a moment for existing tools to load then replace
	wait(1)
	ClearExistingTools()
	wait(0.5)
	
	-- Tool 1: Pie to the Face
	local pieTool = CreateToolBase("ğŸ¥§ Pie to the Face", COLORS.Cream, "ğŸ¥§")
	pieTool.ToolTip = "[E] Throw a cream pie - Stun & Damage"
	pieTool.Parent = backpack
	
	pieTool.Activated:Connect(function()
		Tools.Skill1_Pie()
	end)
	
	-- Tool 2: Balloon Animal Barrage
	local balloonTool = CreateToolBase("ğŸˆ Balloon Barrage", COLORS.Pink, "ğŸˆ")
	balloonTool.ToolTip = "[R] Launch 6 balloon animals"
	balloonTool.Parent = backpack
	
	balloonTool.Activated:Connect(function()
		Tools.Skill2_Balloons()
	end)
	
	-- Tool 3: Honk Shockwave
	local honkTool = CreateToolBase("ğŸ“¯ Honk Shockwave", COLORS.Orange, "ğŸ“¯")
	honkTool.ToolTip = "[T] Devastating AoE shockwave"
	honkTool.Parent = backpack
	
	honkTool.Activated:Connect(function()
		Tools.Skill3_Honk()
	end)
	
	-- Tool 4: Juggling Frenzy
	local juggleTool = CreateToolBase("ğŸ¤¹ Juggling Frenzy", COLORS.Gold, "ğŸ¤¹")
	juggleTool.ToolTip = "[F] Grab and juggle your enemy"
	juggleTool.Parent = backpack
	
	juggleTool.Activated:Connect(function()
		Tools.Skill4_Juggle()
	end)
	
	-- Tool 5: Ultimate
	local ultTool = CreateToolBase("ğŸª THE BIG TOP", COLORS.HotPink, "ğŸª")
	ultTool.ToolTip = "[G] ULTIMATE - Requires full meter"
	ultTool.Parent = backpack
	
	ultTool.Activated:Connect(function()
		Tools.Ultimate()
	end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- UI SYSTEM (Custom Overlay)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local UI = {}

function UI.Create()
	local pg = Player:WaitForChild("PlayerGui")
	
	-- Destroy old if exists
	local old = pg:FindFirstChild("ClownOverlayUI")
	if old then old:Destroy() end
	
	local sg = Instance.new("ScreenGui")
	sg.Name = "ClownOverlayUI"
	sg.ResetOnSpawn = false
	sg.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	sg.DisplayOrder = 100 -- On top
	sg.Parent = pg
	
	-- â•â•â• MAIN ABILITY BAR â•â•â•
	local bar = Instance.new("Frame")
	bar.Name = "AbilityBar"
	bar.Size = UDim2.new(0, 460, 0, 65)
	bar.Position = UDim2.new(0.5, -230, 1, -90)
	bar.BackgroundColor3 = Color3.fromRGB(15, 15, 25)
	bar.BackgroundTransparency = 0.25
	bar.Parent = sg
	
	Instance.new("UICorner", bar).CornerRadius = UDim.new(0, 12)
	
	local barStroke = Instance.new("UIStroke")
	barStroke.Color = COLORS.HotPink
	barStroke.Thickness = 2
	barStroke.Transparency = 0.4
	barStroke.Parent = bar
	
	local layout = Instance.new("UIListLayout")
	layout.FillDirection = Enum.FillDirection.Horizontal
	layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	layout.VerticalAlignment = Enum.VerticalAlignment.Center
	layout.Padding = UDim.new(0, 6)
	layout.Parent = bar
	
	local skills = {
		{Name = "Skill1", Key = "E", Emoji = "ğŸ¥§", Color = COLORS.Cream, Label = "Pie"},
		{Name = "Skill2", Key = "R", Emoji = "ğŸˆ", Color = COLORS.Pink, Label = "Balloon"},
		{Name = "Skill3", Key = "T", Emoji = "ğŸ“¯", Color = COLORS.Orange, Label = "Honk"},
		{Name = "Skill4", Key = "F", Emoji = "ğŸ¤¹", Color = COLORS.Gold, Label = "Juggle"},
		{Name = "Ultimate", Key = "G", Emoji = "ğŸª", Color = COLORS.HotPink, Label = "BIG TOP"},
	}
	
	UI.SkillFrames = {}
	
	for _, sk in ipairs(skills) do
		local frame = Instance.new("Frame")
		frame.Name = sk.Name
		frame.Size = UDim2.new(0, 82, 0, 55)
		frame.BackgroundColor3 = Color3.fromRGB(25, 25, 40)
		frame.BackgroundTransparency = 0.15
		frame.Parent = bar
		
		Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 8)
		
		local stroke = Instance.new("UIStroke")
		stroke.Color = sk.Color
		stroke.Thickness = 1.5
		stroke.Transparency = 0.5
		stroke.Parent = frame
		
		local emoji = Instance.new("TextLabel")
		emoji.Size = UDim2.new(1, 0, 0, 22)
		emoji.Position = UDim2.new(0, 0, 0, 1)
		emoji.BackgroundTransparency = 1
		emoji.Text = sk.Emoji
		emoji.TextSize = 18
		emoji.Font = Enum.Font.GothamBold
		emoji.TextColor3 = Color3.new(1, 1, 1)
		emoji.Parent = frame
		
		local key = Instance.new("TextLabel")
		key.Size = UDim2.new(1, 0, 0, 16)
		key.Position = UDim2.new(0, 0, 0, 22)
		key.BackgroundTransparency = 1
		key.Text = "[" .. sk.Key .. "]"
		key.TextSize = 13
		key.Font = Enum.Font.GothamBlack
		key.TextColor3 = sk.Color
		key.Parent = frame
		
		local name = Instance.new("TextLabel")
		name.Size = UDim2.new(1, 0, 0, 13)
		name.Position = UDim2.new(0, 0, 0, 38)
		name.BackgroundTransparency = 1
		name.Text = sk.Label
		name.TextSize = 9
		name.Font = Enum.Font.Gotham
		name.TextColor3 = Color3.fromRGB(160, 160, 160)
		name.Parent = frame
		
		-- Cooldown overlay
		local cdOverlay = Instance.new("Frame")
		cdOverlay.Name = "CDOverlay"
		cdOverlay.Size = UDim2.new(1, 0, 1, 0)
		cdOverlay.BackgroundColor3 = Color3.new(0, 0, 0)
		cdOverlay.BackgroundTransparency = 0.45
		cdOverlay.Visible = false
		cdOverlay.ZIndex = 5
		cdOverlay.Parent = frame
		Instance.new("UICorner", cdOverlay).CornerRadius = UDim.new(0, 8)
		
		local cdText = Instance.new("TextLabel")
		cdText.Name = "CDText"
		cdText.Size = UDim2.new(1, 0, 1, 0)
		cdText.BackgroundTransparency = 1
		cdText.Text = "0.0"
		cdText.TextSize = 16
		cdText.Font = Enum.Font.GothamBlack
		cdText.TextColor3 = Color3.new(1, 1, 1)
		cdText.ZIndex = 6
		cdText.Parent = cdOverlay
		
		UI.SkillFrames[sk.Name] = {
			Frame = frame,
			CDOverlay = cdOverlay,
			CDText = cdText,
			Stroke = stroke,
		}
	end
	
	-- â•â•â• ULT METER BAR â•â•â•
	local ultBar = Instance.new("Frame")
	ultBar.Name = "UltMeter"
	ultBar.Size = UDim2.new(0, 280, 0, 16)
	ultBar.Position = UDim2.new(0.5, -140, 1, -108)
	ultBar.BackgroundColor3 = Color3.fromRGB(15, 15, 25)
	ultBar.BackgroundTransparency = 0.3
	ultBar.Parent = sg
	
	Instance.new("UICorner", ultBar).CornerRadius = UDim.new(0, 8)
	
	local ultStroke = Instance.new("UIStroke")
	ultStroke.Color = COLORS.HotPink
	ultStroke.Thickness = 1.5
	ultStroke.Parent = ultBar
	
	local ultFill = Instance.new("Frame")
	ultFill.Name = "Fill"
	ultFill.Size = UDim2.new(0, 0, 1, 0)
	ultFill.BackgroundColor3 = COLORS.HotPink
	ultFill.Parent = ultBar
	Instance.new("UICorner", ultFill).CornerRadius = UDim.new(0, 8)
	
	local ultGrad = Instance.new("UIGradient")
	ultGrad.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, COLORS.HotPink),
		ColorSequenceKeypoint.new(0.5, COLORS.Cyan),
		ColorSequenceKeypoint.new(1, COLORS.HotPink),
	})
	ultGrad.Parent = ultFill
	
	local ultLabel = Instance.new("TextLabel")
	ultLabel.Size = UDim2.new(1, 0, 1, 0)
	ultLabel.BackgroundTransparency = 1
	ultLabel.Text = "ğŸª ULTIMATE"
	ultLabel.TextSize = 10
	ultLabel.Font = Enum.Font.GothamBlack
	ultLabel.TextColor3 = Color3.new(1, 1, 1)
	ultLabel.TextStrokeTransparency = 0.4
	ultLabel.ZIndex = 3
	ultLabel.Parent = ultBar
	
	UI.UltFill = ultFill
	UI.UltLabel = ultLabel
	
	-- â•â•â• CHARACTER ICON â•â•â•
	local iconFrame = Instance.new("Frame")
	iconFrame.Name = "ClownIcon"
	iconFrame.Size = UDim2.new(0, 65, 0, 65)
	iconFrame.Position = UDim2.new(0.5, -270, 1, -100)
	iconFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 35)
	iconFrame.BackgroundTransparency = 0.15
	iconFrame.Parent = sg
	
	Instance.new("UICorner", iconFrame).CornerRadius = UDim.new(0.5, 0)
	
	local iconStroke = Instance.new("UIStroke")
	iconStroke.Color = COLORS.Red
	iconStroke.Thickness = 3
	iconStroke.Parent = iconFrame
	
	local clownEmoji = Instance.new("TextLabel")
	clownEmoji.Size = UDim2.new(1, 0, 1, 0)
	clownEmoji.BackgroundTransparency = 1
	clownEmoji.Text = "ğŸ¤¡"
	clownEmoji.TextSize = 38
	clownEmoji.Font = Enum.Font.GothamBlack
	clownEmoji.TextColor3 = Color3.new(1, 1, 1)
	clownEmoji.Parent = iconFrame
	
	-- Animated icon border
	spawn(function()
		local colorCycle = {COLORS.Red, COLORS.Gold, COLORS.Purple, COLORS.Cyan, COLORS.Pink}
		local idx = 1
		while sg.Parent do
			TweenService:Create(iconStroke, TweenInfo.new(0.8, Enum.EasingStyle.Sine), {
				Color = colorCycle[idx]
			}):Play()
			idx = idx % #colorCycle + 1
			wait(0.8)
		end
	end)
	
	-- â•â•â• CHARACTER NAME â•â•â•
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Size = UDim2.new(0, 150, 0, 20)
	nameLabel.Position = UDim2.new(0.5, -265, 1, -30)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = "ğŸ¤¡ THE CLOWN"
	nameLabel.TextSize = 14
	nameLabel.Font = Enum.Font.GothamBlack
	nameLabel.TextColor3 = COLORS.Red
	nameLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
	nameLabel.TextStrokeTransparency = 0
	nameLabel.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel.Parent = sg
	
	-- â•â•â• COMBO COUNTER â•â•â•
	local combo = Instance.new("TextLabel")
	combo.Name = "ComboCounter"
	combo.Size = UDim2.new(0, 150, 0, 50)
	combo.Position = UDim2.new(0.5, 180, 0.5, -25)
	combo.BackgroundTransparency = 1
	combo.Text = ""
	combo.TextSize = 36
	combo.Font = Enum.Font.GothamBlack
	combo.TextColor3 = COLORS.Gold
	combo.TextStrokeColor3 = Color3.new(0, 0, 0)
	combo.TextStrokeTransparency = 0
	combo.TextTransparency = 1
	combo.Parent = sg
	
	UI.ComboLabel = combo
	UI.ScreenGui = sg
end

function UI.UpdateCooldowns()
	if not UI.SkillFrames then return end
	
	for skillName, data in pairs(UI.SkillFrames) do
		local cd = State.Cooldowns[skillName]
		if cd and cd > tick() then
			data.CDOverlay.Visible = true
			data.CDText.Text = string.format("%.1f", cd - tick())
			data.Stroke.Transparency = 0.8
		else
			data.CDOverlay.Visible = false
			data.Stroke.Transparency = 0.5
		end
	end
	
	-- Update ult meter
	if UI.UltFill then
		local fill = State.UltMeter / State.UltMax
		TweenService:Create(UI.UltFill, TweenInfo.new(0.15), {
			Size = UDim2.new(fill, 0, 1, 0)
		}):Play()
		
		if State.UltMeter >= State.UltMax then
			UI.UltLabel.Text = "ğŸª READY! [G]"
		else
			UI.UltLabel.Text = "ğŸª ULTIMATE"
		end
	end
end

function UI.ShowCombo(count)
	if not UI.ComboLabel then return end
	UI.ComboLabel.Text = count .. " ğŸ’¥"
	UI.ComboLabel.TextTransparency = 0
	UI.ComboLabel.TextStrokeTransparency = 0
	UI.ComboLabel.TextSize = 45
	
	TweenService:Create(UI.ComboLabel, TweenInfo.new(0.08, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		TextSize = 36,
	}):Play()
	
	spawn(function()
		local txt = count .. " ğŸ’¥"
		wait(1.2)
		if UI.ComboLabel and UI.ComboLabel.Text == txt then
			TweenService:Create(UI.ComboLabel, TweenInfo.new(0.3), {
				TextTransparency = 1,
				TextStrokeTransparency = 1,
			}):Play()
		end
	end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- OVERRIDE THE EXISTING TSB UI / BAR
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local function OverrideExistingUI()
	spawn(function()
		local pg = Player:WaitForChild("PlayerGui")
		wait(3)
		
		for _, gui in pairs(pg:GetChildren()) do
			if gui:IsA("ScreenGui") and gui.Name ~= "ClownOverlayUI" and gui.Name ~= "UltTextGui" then
				for _, desc in pairs(gui:GetDescendants()) do
					-- Replace character images
					if desc:IsA("ImageLabel") or desc:IsA("ImageButton") then
						local n = desc.Name:lower()
						if n:find("icon") or n:find("char") or n:find("avatar") or n:find("portrait") 
						   or n:find("saitama") or n:find("punch") or n:find("thumb") then
							desc.ImageTransparency = 1
							
							-- Check if we already added a replacement
							if not desc:FindFirstChild("ClownReplace") then
								local replace = Instance.new("TextLabel")
								replace.Name = "ClownReplace"
								replace.Size = UDim2.new(1, 0, 1, 0)
								replace.BackgroundTransparency = 1
								replace.Text = "ğŸ¤¡"
								replace.TextScaled = true
								replace.Font = Enum.Font.GothamBlack
								replace.TextColor3 = Color3.new(1, 1, 1)
								replace.ZIndex = desc.ZIndex + 1
								replace.Parent = desc
							end
						end
					end
					
					-- Replace character name text
					if desc:IsA("TextLabel") or desc:IsA("TextButton") then
						local t = desc.Text:lower()
						if t:find("saitama") or t:find("one punch") or t:find("opm") or t:find("normal") then
							desc.Text = "ğŸ¤¡ THE CLOWN"
							desc.TextColor3 = COLORS.Red
						end
					end
				end
			end
		end
	end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CLOWN APPEARANCE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local function ApplyClownAppearance()
	spawn(function()
		wait(0.5)
		if not Character then return end
		
		local head = Character:FindFirstChild("Head")
		if head then
			-- Red clown nose
			local existingNose = Character:FindFirstChild("ClownNose")
			if existingNose then existingNose:Destroy() end
			
			local nose = Instance.new("Part")
			nose.Name = "ClownNose"
			nose.Size = Vector3.new(0.55, 0.55, 0.55)
			nose.Shape = Enum.PartType.Ball
			nose.Material = Enum.Material.SmoothPlastic
			nose.Color = Color3.fromRGB(255, 0, 0)
			nose.CanCollide = false
			nose.Massless = true
			nose.Parent = Character
			
			local weld = Instance.new("WeldConstraint")
			weld.Part0 = head
			weld.Part1 = nose
			weld.Parent = nose
			nose.CFrame = head.CFrame * CFrame.new(0, -0.15, -0.62)
			
			local noseGlow = Instance.new("PointLight")
			noseGlow.Color = Color3.fromRGB(255, 0, 0)
			noseGlow.Brightness = 0.8
			noseGlow.Range = 4
			noseGlow.Parent = nose
			
			-- Name tag
			local existingTag = head:FindFirstChild("ClownTag")
			if existingTag then existingTag:Destroy() end
			
			local tag = Instance.new("BillboardGui")
			tag.Name = "ClownTag"
			tag.Size = UDim2.new(0, 150, 0, 40)
			tag.StudsOffset = Vector3.new(0, 2.5, 0)
			tag.AlwaysOnTop = false
			tag.Parent = head
			
			local tagLabel = Instance.new("TextLabel")
			tagLabel.Size = UDim2.new(1, 0, 1, 0)
			tagLabel.BackgroundTransparency = 1
			tagLabel.Text = "ğŸ¤¡"
			tagLabel.TextSize = 28
			tagLabel.Font = Enum.Font.GothamBlack
			tagLabel.TextColor3 = COLORS.Red
			tagLabel.TextStrokeTransparency = 0
			tagLabel.Parent = tag
		end
	end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- INPUT HANDLER
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local function SetupInput()
	UserInputService.InputBegan:Connect(function(input, gp)
		if gp then return end
		
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			Tools.M1Attack()
			if State.M1Count > 0 then
				UI.ShowCombo(State.M1Count)
			end
		end
		
		if input.UserInputType == Enum.UserInputType.Keyboard then
			if input.KeyCode == Enum.KeyCode.E then
				Tools.Skill1_Pie()
			elseif input.KeyCode == Enum.KeyCode.R then
				Tools.Skill2_Balloons()
			elseif input.KeyCode == Enum.KeyCode.T then
				Tools.Skill3_Honk()
			elseif input.KeyCode == Enum.KeyCode.F then
				Tools.Skill4_Juggle()
			elseif input.KeyCode == Enum.KeyCode.G then
				Tools.Ultimate()
			elseif input.KeyCode == Enum.KeyCode.Q then
				Tools.Dash()
			end
		end
		
		if input.UserInputType == Enum.UserInputType.MouseButton2 then
			Tools.StartBlock()
		end
	end)
	
	UserInputService.InputEnded:Connect(function(input, gp)
		if input.UserInputType == Enum.UserInputType.MouseButton2 then
			Tools.StopBlock()
		end
	end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MAIN LOOP
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local function StartLoop()
	-- Ult ready notification
	local ultNotified = false
	
	RunService.Heartbeat:Connect(function(dt)
		-- Character refresh
		if Player.Character and Player.Character ~= Character then
			CacheCharacter(Player.Character)
			ApplyClownAppearance()
			OverrideExistingUI()
			Anim.StartClownIdle()
		end
		
		-- UI updates
		UI.UpdateCooldowns()
		
		-- Ult ready notification
		if State.UltMeter >= State.UltMax and not ultNotified and not State.UltActive then
			ultNotified = true
			
			local pg = Player:FindFirstChild("PlayerGui")
			if pg and UI.ScreenGui then
				local readyLabel = Instance.new("TextLabel")
				readyLabel.Size = UDim2.new(0, 300, 0, 35)
				readyLabel.Position = UDim2.new(0.5, -150, 0.42, 0)
				readyLabel.BackgroundTransparency = 1
				readyLabel.Text = "ğŸª ULTIMATE READY! [G] ğŸª"
				readyLabel.TextSize = 22
				readyLabel.Font = Enum.Font.GothamBlack
				readyLabel.TextColor3 = COLORS.HotPink
				readyLabel.TextStrokeTransparency = 0
				readyLabel.Parent = UI.ScreenGui
				
				-- Flash
				spawn(function()
					for j = 1, 4 do
						TweenService:Create(readyLabel, TweenInfo.new(0.15), {TextColor3 = COLORS.Cyan}):Play()
						wait(0.15)
						TweenService:Create(readyLabel, TweenInfo.new(0.15), {TextColor3 = COLORS.HotPink}):Play()
						wait(0.15)
					end
					TweenService:Create(readyLabel, TweenInfo.new(0.5), {
						TextTransparency = 1,
						TextStrokeTransparency = 1,
					}):Play()
					Debris:AddItem(readyLabel, 0.6)
				end)
			end
		elseif State.UltMeter < State.UltMax then
			ultNotified = false
		end
	end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- INIT
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local function Init()
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	print("ğŸ¤¡ CLOWN MOVESET V2 - LOADING...")
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	
	wait(2)
	
	print("[Clown] Creating UI...")
	UI.Create()
	
	print("[Clown] Creating tools...")
	CreateClownTools()
	
	print("[Clown] Setting up input...")
	SetupInput()
	
	print("[Clown] Applying appearance...")
	ApplyClownAppearance()
	
	print("[Clown] Overriding existing UI...")
	OverrideExistingUI()
	
	print("[Clown] Starting idle animation...")
	Anim.StartClownIdle()
	
	print("[Clown] Starting main loop...")
	StartLoop()
	
	-- Respawn handler
	Player.CharacterAdded:Connect(function(newChar)
		wait(1)
		CacheCharacter(newChar)
		
		State.Attacking = false
		State.Blocking = false
		State.UsingSkill = false
		State.Dashing = false
		State.UltActive = false
		State.Awakened = false
		State.Animating = false
		State.M1Count = 0
		
		wait(0.5)
		CreateClownTools()
		ApplyClownAppearance()
		OverrideExistingUI()
		Anim.StartClownIdle()
	end)
	
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	print("ğŸ¤¡ CLOWN MOVESET V2 - LOADED! ğŸ¤¡")
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	print("")
	print("  LMB  - Slapstick Combo (5-hit M1)")
	print("  [E]  - ğŸ¥§ Pie to the Face")
	print("  [R]  - ğŸˆ Balloon Animal Barrage")
	print("  [T]  - ğŸ“¯ Honk Shockwave")
	print("  [F]  - ğŸ¤¹ Juggling Frenzy")
	print("  [G]  - ğŸª THE BIG TOP (Ultimate)")
	print("  [Q]  - Cartwheel Dash")
	print("  RMB  - Block")
	print("")
end

Init()
